<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于MainLine Kernel Pinctrl子系统分析</title>
    <link href="/2025/05/05/Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/05/05/Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本数据结构"><a href="#一、基本数据结构" class="headerlink" title="一、基本数据结构"></a>一、基本数据结构</h2><h3 id="1-pinctroller"><a href="#1-pinctroller" class="headerlink" title="1. pinctroller"></a>1. pinctroller</h3><p>pinctrl_dev 与 pinctrl_desc</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs clean">struct pinctrl_dev &#123;<br>struct list_head node;<br>struct pinctrl_desc *desc;<br>struct radix_tree_root pin_desc_tree;<br>#ifdef CONFIG_GENERIC_PINCTRL_GROUPS<br>struct radix_tree_root pin_group_tree;<br>unsigned int num_groups;<br>#endif<br>#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS<br>struct radix_tree_root pin_function_tree;<br>unsigned int num_functions;<br>#endif<br>struct list_head gpio_ranges;<br>struct device *dev;<br>struct <span class="hljs-keyword">module</span> *owner;<br>void *driver_data;<br>struct pinctrl *p;<br>struct pinctrl_state *hog_default;<br>struct pinctrl_state *hog_sleep;<br>struct mutex mutex;<br>#ifdef CONFIG_DEBUG_FS<br>struct dentry *device_root;<br>#endif<br>&#125;<br><br>##########################################<br>##########################################<br><br>struct pinctrl_desc &#123;<br>const char *name;<br>const struct pinctrl_pin_desc *pins;<br>unsigned int npins;<br>const struct pinctrl_ops *pctlops;<br>const struct pinmux_ops *pmxops;<br>const struct pinconf_ops *confops;<br>struct <span class="hljs-keyword">module</span> *owner;<br>#ifdef CONFIG_GENERIC_PINCONF<br>unsigned int num_custom_params;<br>const struct pinconf_generic_params *custom_params;<br>const struct pin_config_item *custom_conf_items;<br>#endif<br>bool link_consumers;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们进入到驱动目录里 drivers\pinctrl\freescale\pinctrl-imx.c 的 .probe函数</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">int imx_pinctrl_probe(struct platform_device *pdev,<br>      const struct imx_pinctrl_soc_info *info)<br>&#123;<br>struct regmap_config config = &#123; .<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;gpr&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *dev_np = pdev-&gt;</span>dev.of_node;<br>struct pinctrl_desc *imx_pinctrl_desc;<br>struct device_node *np;<br>struct imx_pinctrl *ipctl;<br>struct regmap *gpr;<br>int ret, i;<br>...<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span> = info-&gt;</span>pins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">npins</span> = info-&gt;</span>npins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pctlops = &amp;imx_pctrl_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pmxops = &amp;imx_pmx_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>confops = &amp;imx_pinconf_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>owner = THIS_MODULE;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中比较重要的，struct pctlops 、struct pmxops，pinconf_ops,我们看看他们的结构体时怎么构造的</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs clean">struct pinctrl_ops &#123;<br>int (*get_groups_count) (struct pinctrl_dev *pctldev);<br>const char *(*get_group_name) (struct pinctrl_dev *pctldev,<br>       unsigned int selector);<br>int (*get_group_pins) (struct pinctrl_dev *pctldev,<br>       unsigned int selector,<br>       const unsigned int **pins,<br>       unsigned int *num_pins);<br>void (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s,<br>      unsigned int offset);<br>int (*dt_node_to_map) (struct pinctrl_dev *pctldev,<br>       struct device_node *np_config,<br>       struct pinctrl_map **map, unsigned int *num_maps);<br>void (*dt_free_map) (struct pinctrl_dev *pctldev,<br>     struct pinctrl_map *map, unsigned int num_maps);<br>&#125;;<br><br>##################################<br><br>struct pinmux_ops &#123;<br>int (*request) (struct pinctrl_dev *pctldev, unsigned int offset);<br>int (*free) (struct pinctrl_dev *pctldev, unsigned int offset);<br>int (*get_functions_count) (struct pinctrl_dev *pctldev);<br>const char *(*get_function_name) (struct pinctrl_dev *pctldev,<br>  unsigned int selector);<br>int (*get_function_groups) (struct pinctrl_dev *pctldev,<br>    unsigned int selector,<br>    const char * const **groups,<br>    unsigned int *num_groups);<br>int (*set_mux) (struct pinctrl_dev *pctldev, unsigned int func_selector,<br>unsigned int group_selector);<br>int (*gpio_request_enable) (struct pinctrl_dev *pctldev,<br>    struct pinctrl_gpio_range *range,<br>    unsigned int offset);<br>.....<br>&#125;;<br><br>#############################################<br>struct pinconf_ops &#123;<br>#ifdef CONFIG_GENERIC_PINCONF<br>bool is_generic;<br>#endif<br>int (*pin_config_get) (struct pinctrl_dev *pctldev,<br>       unsigned int pin,<br>       unsigned long *config);<br>int (*pin_config_set) (struct pinctrl_dev *pctldev,<br>       unsigned int pin,<br>       unsigned long *configs,<br>       unsigned int num_configs);<br>int (*pin_config_group_get) (struct pinctrl_dev *pctldev,<br>     unsigned int selector,<br>     unsigned long *config);<br>int (*pin_config_group_set) (struct pinctrl_dev *pctldev,<br>     unsigned int selector,<br>     unsigned long *configs,<br>     unsigned int num_configs);<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先来解释为什么要有 pinctrl_ops 这么一个结构体呢？我们可以看到 struct pinctrl_desc 里有这么两个属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> *pins;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">void</span> *drv_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这两个属性都是用来描述单个引脚的，而看 pinctrl_ops 提供的函数，可以获得多个group里的pin信息（提供 groups、pins、group和pin之间的组织关系）。</p><p>然后再来看 pinmux_ops 结构体，比较重要的函数就是他就是set_mux(),来把  pinctrl_ops 获取 的 描述信息去设置mux寄存器(复用为什么功能，GPIO、UART、SPI之类)。</p><p>可以理解为：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">驱动请求(pinctrl_select_state)<br>    ↓<br>根据设备树找 pinctrl <span class="hljs-keyword">state</span><br>    ↓<br>根据 pctlops 描述，找到对应的 <span class="hljs-keyword">group</span>(s)<br>    ↓<br>调用 pmxops-&gt;set_mux，把 pins 设置到正确的功能<br></code></pre></td></tr></table></figure><p>最后就是 pinconf_ops ，它的作用是配置 pin 的电气属性（上拉、下拉、驱动强度等）。</p><p>以上就是pinctroller端的基本数据结构.</p><h3 id="2-注册函数"><a href="#2-注册函数" class="headerlink" title="2.注册函数"></a>2.注册函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *<span class="hljs-built_in">pinctrl_register</span>(<span class="hljs-keyword">struct</span> pinctrl_desc *pctldesc,<br>    <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">void</span> *driver_data);<br></code></pre></td></tr></table></figure><p>可以看到参数是一个 struct pinctrl_desc，而返回值是 struct pinctrl_dev，以后就用 pinctrl_dev 来描述一个 pincontroller。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"> pinctrl_flexcan1: flexcan1grp &#123;<br>         fsl,pins = &lt;<br>                 MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX      <span class="hljs-number">0x1b020</span><br>                 MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX      <span class="hljs-number">0x1b020</span><br>         &gt;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面分析的数据结构都是来描述这个 pincontroller.</p><h3 id="4-pinctrl-client"><a href="#4-pinctrl-client" class="headerlink" title="4.pinctrl  client"></a>4.pinctrl  client</h3><p>但是我们在使用中还有一个client，这部分是怎么描述的？</p><p>先看在dtb中的编写:通过 pinctrl-names 的属性来选择 pin要配置为什么模式。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">device</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span>，<span class="hljs-string">&quot;sleep&quot;</span><span class="hljs-punctuation">;</span><br>        pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_device0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        pinctrl<span class="hljs-number">-1</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_device1</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>首先设备树会被编译成 platform_device结构体（不全是，比如i2c_client）,但是里面都会有一个 device 结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct platform_device &#123;<br>const char*name<span class="hljs-comment">;</span><br>intid<span class="hljs-comment">;</span><br>boolid_auto<span class="hljs-comment">;</span><br>struct devicedev<span class="hljs-comment">;           《--------------</span><br>u64platform_dma_mask<span class="hljs-comment">;</span><br>....<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">i2c_client</span> &#123;<br>...<br><span class="hljs-keyword">struct</span> <span class="hljs-type">i2c_adapter</span> *adapter;<span class="hljs-comment">/* the adapter we sit on*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">device</span> dev;<span class="hljs-comment">/* the device structure*/</span>               《--------------<br>int init_irq;<span class="hljs-comment">/* irq set at initialization*/</span><br>int irq;<span class="hljs-comment">/* irq issued by device*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> detected;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以不管被编译为什么结构体，最终都汇聚到这个 struct device 来和 pinctrl 挂钩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> &#123;<br>...<br><span class="hljs-type">void</span>*platform_data;<span class="hljs-comment">/* Platform specific data, device</span><br><span class="hljs-comment">   core doesn&#x27;t touch it */</span><br><span class="hljs-type">void</span>*driver_data;<span class="hljs-comment">/* Driver data, set and get with</span><br><span class="hljs-comment">   dev_set_drvdata/dev_get_drvdata */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mutex</span>mutex;<span class="hljs-comment">/* mutex to synchronize calls to</span><br><span class="hljs-comment"> * its driver.</span><br><span class="hljs-comment"> */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PINCTRL</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dev_pin_info</span>*pins;            &lt;-------------------------<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dev_msi_info</span>msi;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_HAS_DMA_OPS</span><br>        <span class="hljs-type">const</span> <br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>就是通过  struct dev_pin_info *pins 和 pinctrl 挂钩的。</p><h4 id="4-1struct-dev-pin-info"><a href="#4-1struct-dev-pin-info" class="headerlink" title="4.1struct dev_pin_info"></a>4.1struct dev_pin_info</h4><p>这个结构体只在需要使用pinctrl 子系统时构造。</p><p>可以看出这几个 pinctrl_state 结构体都是由 dtb中的 pinctrl client 的 pinctrl-names 属性构造的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">dev_pin_info</span> &#123;<br><span class="hljs-comment">/* 存放自己添加的状态 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl</span> *p;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *default_state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *init_state;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *sleep_state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *idle_state;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-2自定义状态"><a href="#4-2自定义状态" class="headerlink" title="4.2自定义状态"></a>4.2自定义状态</h4><p>则都是几种常用的状态，那么有没有方法让我们自定义状态呢？</p><p>有的兄弟，有的。</p><p>我们自定义的状态会放在 struct pinctrl *p 里的 struct list_head states 链表里，（关于解析部分之后分析）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">device</span> *dev;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> states;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> dt_maps;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">kref</span> users;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-3pinctrl-map-和-pinctrl-setting"><a href="#4-3pinctrl-map-和-pinctrl-setting" class="headerlink" title="4.3pinctrl_map  和 pinctrl_setting"></a>4.3pinctrl_map  和 pinctrl_setting</h4><p>当我们的pinctrl cliend 想要去使用pinctrl，是通过 struct dev_pin_info 去建立联系的，那么我们 pinctroller 的设备节点也得需要去保存到这个结构体里。</p><p>还记得 pctlops 吗，就是它来解析的，它是来处理一组引脚的。这个结构体里有一个函数 dt_node_to_map().</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">int</span> (*dt_node_to_map) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev,<br>               <span class="hljs-keyword">struct</span> device_node *np_config,<br>               <span class="hljs-keyword">struct</span> pinctrl_map **map, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *num_maps);<br></code></pre></td></tr></table></figure><p>就是来把设备树节点转换为一系列的 pinctrl_map 结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map</span> &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *dev_name;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">pinctrl_map_type</span> <span class="hljs-keyword">type</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *ctrl_dev_name;<br><span class="hljs-keyword">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map_mux</span> mux;          <span class="hljs-comment">/* 复用哪些引脚 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map_configs</span> configs;  <span class="hljs-comment">/* 配置哪些引脚 */</span><br>&#125; data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再有 struct pinctrl_map —&gt; struct pinctrl_setting ,去配置这些引脚的功能。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br>enum pinctrl_map_type <span class="hljs-built_in">type</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_dev</span> *pctldev;<br>const char *dev_name;<br><span class="hljs-built_in">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting_mux</span> mux;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting_configs</span> configs;<br>&#125; data;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br>const char *name;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> settings;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个 struct pinctrl_setting又存放在 pinctrl_state.settings里，以后让这个设备位于某个状态时，就会根据这些 .settings来设置引脚。</p><p>（map —&gt;setting 这部分是内核的工作，想了解可以查看  drivers\pinctrl\core.c）</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">pinctrl_get</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pinctrl</span>()</span><br><span class="hljs-function"><span class="hljs-title">pinctrl_dt_to_map</span>()</span><br><span class="hljs-function"><span class="hljs-title">add_setting</span>()</span><br></code></pre></td></tr></table></figure><h4 id="4-4操作流程"><a href="#4-4操作流程" class="headerlink" title="4.4操作流程"></a>4.4操作流程</h4><p>看一下怎么来根据 .setting 来设置引脚的，进入内核目录 drivers\base\dd.c，查看 really_probe() 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">really_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> test_remove = <span class="hljs-built_in">IS_ENABLED</span>(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;<br>   !drv-&gt;suppress_bind_attrs;<br><span class="hljs-type">int</span> ret, link_ret;<br>...<br><span class="hljs-comment">/* If using pinctrl, bind pins now before probing */</span><br>ret = <span class="hljs-built_in">pinctrl_bind_pins</span>(dev);    &lt;-----------------<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> pinctrl_bind_failed;<br>&#125;<br></code></pre></td></tr></table></figure><p>会看到有一个 pinctrl_bind_pins(),进入查看</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinctrl_bind_pins(struct device *dev)<br>&#123;<br>...<br>    <span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state)) &#123;<br>    <span class="hljs-comment">/* Not supplying this state is perfectly legal */</span><br>    dev_dbg(dev, <span class="hljs-string">&quot;no init pinctrl state\n&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p,<br>                   <span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>default_state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">p</span>, dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>找到一个选择状态函数 pinctrl_select_state(),接着进入</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *<span class="hljs-keyword">state</span>)<br>&#123;<br>if (p-&gt;state == <span class="hljs-keyword">state</span>)<br>return <span class="hljs-number">0</span>;<br><br>return pinctrl_commit_state(p, <span class="hljs-keyword">state</span>);   <span class="hljs-variable">&lt;-------------</span><br><span class="hljs-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>这里会判断一下初始化的状态是否正常，接着进入 pinctrl_commit_state().</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)<br>&#123;<br>struct pinctrl_setting *setting;<br>struct pinctrl_state *old_state = READ_ONCE(p-&gt;state);<br><span class="hljs-keyword">int</span> ret;<br>...<br><span class="hljs-comment">/* Apply all the settings for the new state - pinmux first */</span><br>list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;         &lt;-------------<br><span class="hljs-keyword">switch</span> (setting-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = pinmux_enable_setting(setting);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = <span class="hljs-number">0</span>;   <span class="hljs-comment">//跳过</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>goto unapply_new_state;<br><br><span class="hljs-comment">/* Do not link hogs (circular dependency) */</span><br><span class="hljs-keyword">if</span> (p != setting-&gt;pctldev-&gt;p)<br>pinctrl_link_add(setting-&gt;pctldev, p-&gt;dev);<br>&#125;<br><br><span class="hljs-comment">/* Apply all the settings for the new state - pinconf after */</span><br>list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123; &lt;-------------<br><span class="hljs-keyword">switch</span> (setting-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = <span class="hljs-number">0</span>;   <span class="hljs-comment">// mux 已完成，跳过</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = pinconf_apply_setting(setting);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个switch 语句，这样分布的机制就是为了保证在做 config 设置前，引脚已经正确映射到目标功能（比如 UART1_TX），否则如果 pin 还处于 GPIO 模式，你设置电平、上拉下拉等都没有意义。</p><p>根据 setting-&gt;type 来执行相应的配置函数，对于mux部分执行 pinmux_enable_setting（）,最终调用到了 set_mux 函数来配置引脚的复用。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinmux_enable_setting(const struct pinctrl_setting *setting)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinctrl_ops *pctlops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>pctlops;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinmux_ops *ops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>pmxops;<br>...<br><span class="hljs-function"><span class="hljs-title">ret</span> = ops-&gt;</span><span class="hljs-function"><span class="hljs-title">set_mux</span>(pctldev, setting-&gt;</span><span class="hljs-keyword">data</span>.mux.func,<br>   <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.mux.group);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 config 部分执行 pinconf_apply_setting（），最终调用到了 pin_config_group_set().</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinconf_apply_setting(const struct pinctrl_setting *setting)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinconf_ops *ops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>confops;<br>int ret;<br>...<br>    <span class="hljs-function"><span class="hljs-title">ret</span> = ops-&gt;</span>pin_config_group_set(pctldev,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.group_or_pin,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.configs,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.num_configs);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>根据之前在.probe 分配注册的函数，就是在这里被执行的.</p><h2 id="二、DTB解析"><a href="#二、DTB解析" class="headerlink" title="二、DTB解析"></a>二、DTB解析</h2><h3 id="1-pincontroller"><a href="#1-pincontroller" class="headerlink" title="1.pincontroller"></a>1.pincontroller</h3><h4 id="3-1首先是描述、获得引脚"><a href="#3-1首先是描述、获得引脚" class="headerlink" title="3.1首先是描述、获得引脚"></a>3.1首先是描述、获得引脚</h4><p>打开内核源码目录  drivers\pinctrl\freescale\pinctrl-imx6ul.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> imx6ul_pinctrl_of_match[] = &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>, .data = &amp;imx6ul_pinctrl_info, &#125;,<br>&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ull-iomuxc-snvs&quot;</span>, .data = &amp;imx6ull_snvs_pinctrl_info, &#125;,<br>&#123; <span class="hljs-comment">/* sentinel */</span> &#125;<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_driver</span> imx6ul_pinctrl_driver = &#123;<br>.driver = &#123;<br>.name = <span class="hljs-string">&quot;imx6ul-pinctrl&quot;</span>,<br>.of_match_table = imx6ul_pinctrl_of_match,<br>.suppress_bind_attrs = <span class="hljs-literal">true</span>,<br>&#125;,<br>.probe = imx6ul_pinctrl_probe,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">imx6ul_pinctrl_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl_soc_info</span> *pinctrl_info;<br><br>pinctrl_info = <span class="hljs-built_in">of_device_get_match_data</span>(&amp;pdev-&gt;dev);<br><span class="hljs-keyword">if</span> (!pinctrl_info)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">imx_pinctrl_probe</span>(pdev, pinctrl_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 platform_driver 支持  “fsl,imx6ul-iomuxc”、”fsl,imx6ull-iomuxc-snvs”这两个平台设备，然后再probe函数调用 imx_pinctrl_probe</p><p>进入到 imx_pinctrl_probe(pdev, pinctrl_info)</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">int imx_pinctrl_probe(struct platform_device *pdev,<br>      const struct imx_pinctrl_soc_info *info)<br>&#123;<br>struct regmap_config config = &#123; .<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;gpr&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *dev_np = pdev-&gt;</span>dev.of_node;<br>struct pinctrl_desc *imx_pinctrl_desc;<br>struct device_node *np;<br>struct imx_pinctrl *ipctl;<br>struct regmap *gpr;<br>int ret, i;<br>...<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(*imx_pinctrl_desc),<br>GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!imx_pinctrl_desc)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span> = info-&gt;</span>pins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">npins</span> = info-&gt;</span>npins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pctlops = &amp;imx_pctrl_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pmxops = &amp;imx_pmx_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>confops = &amp;imx_pinconf_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>owner = THIS_MODULE;<br>...<br><br>...<br>ret = imx_pinctrl_probe_dt(pdev, ipctl);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>看重点，这里就是在构造一个 pinctrl_desc 的结构体。</p><p>那么引脚是怎么获得的呢？</p><h4 id="3-2解析设备树"><a href="#3-2解析设备树" class="headerlink" title="3.2解析设备树"></a>3.2解析设备树</h4><p>进入 imx_pinctrl_probe_dt()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> int <span class="hljs-title function_ invoke__">imx_pinctrl_probe_dt</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_device</span> *pdev,<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl</span> *ipctl)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device_node</span> *np = pdev<span class="hljs-punctuation">-&gt;</span>dev.of_node;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device_node</span> *child;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *pctl = ipctl<span class="hljs-punctuation">-&gt;</span>pctl;<br><span class="hljs-type">u32</span> nfuncs = <span class="hljs-number">0</span>;<br><span class="hljs-type">u32</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flat_funcs;<br><br><span class="hljs-keyword">if</span> (!np)<br><span class="hljs-keyword">return</span> -ENODEV;<br><span class="hljs-comment">/* 判断设备树结构是不是 flat 模式 */</span><br>flat_funcs = <span class="hljs-title function_ invoke__">imx_pinctrl_dt_is_flat_functions</span>(np);<br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br>nfuncs = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* 获得有多少个function (多少个子节点) */</span><br>nfuncs = <span class="hljs-title function_ invoke__">of_get_child_count</span>(np);<br><span class="hljs-keyword">if</span> (nfuncs == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-title function_ invoke__">dev_err</span>(&amp;pdev<span class="hljs-punctuation">-&gt;</span>dev, <span class="hljs-string">&quot;no functions defined\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 对于每一个function(子节点) 都会去分配一个 function_desc 结构体*/</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nfuncs; i++) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">function_desc</span> *function;<br><br>function = <span class="hljs-title function_ invoke__">devm_kzalloc</span>(&amp;pdev<span class="hljs-punctuation">-&gt;</span>dev, <span class="hljs-title function_ invoke__">sizeof</span>(*function),<br>GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!function)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-title function_ invoke__">mutex_lock</span>(&amp;ipctl<span class="hljs-punctuation">-&gt;</span>mutex);<br><span class="hljs-title function_ invoke__">radix_tree_insert</span>(&amp;pctl<span class="hljs-punctuation">-&gt;</span>pin_function_tree, i, function);<br><span class="hljs-title function_ invoke__">mutex_unlock</span>(&amp;ipctl<span class="hljs-punctuation">-&gt;</span>mutex);<br>&#125;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_functions = nfuncs;<br><br>ipctl<span class="hljs-punctuation">-&gt;</span>group_index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups = <span class="hljs-title function_ invoke__">of_get_child_count</span>(np);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups = <span class="hljs-number">0</span>;<br>for_each_child_of_node(np, child)<br><span class="hljs-comment">/* 计算子function下又有多少个group(子节点)*/</span><br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups += <span class="hljs-title function_ invoke__">of_get_child_count</span>(child);<br>&#125;<br><br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br><span class="hljs-title function_ invoke__">imx_pinctrl_parse_functions</span>(np, ipctl, <span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i = <span class="hljs-number">0</span>;<br>for_each_child_of_node(np, child)<br><span class="hljs-title function_ invoke__">imx_pinctrl_parse_functions</span>(child, ipctl, i++);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用 <code>imx_pinctrl_parse_functions()</code>，从设备树中提取每个 function 下的 group 和 pins，解析结构体并缓存。</p><p>补充：这里多次判断了 flat_funcs 这个值，设备树有两种组织形式：</p><p>（1）Flat 模式：所有 group 都直接定义在顶层 iomuxc 节点下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">pinctrl<span class="hljs-meta">@20e0000</span> &#123;<br>    pinctrl_uart1: uart1grp &#123;<br>        fsl,pins = <span class="hljs-variable">&lt;...&gt;</span>;<br>    &#125;;<br>    pinctrl_i2c1: i2c1grp &#123;<br>        fsl,pins = <span class="hljs-variable">&lt;...&gt;</span>;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）Function 分组模式（非 flat）：顶层为 function，function 下再分 group</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">pinctrl<span class="hljs-operator">@</span><span class="hljs-number">20e0000</span> &#123;<br>    <span class="hljs-keyword">uart1</span> &#123;<br>        <span class="hljs-keyword">uart1grp</span> &#123;<br>            fsl,pins <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;...&gt;</span>;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-keyword">i2c1</span> &#123;<br>        <span class="hljs-keyword">i2c1grp</span> &#123;<br>            fsl,pins <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;...&gt;</span>;<br>        &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接着来看具体怎么解析的，首先是 function</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int imx_pinctrl_parse_functions(struct device_node *np,<br>                           struct imx_pinctrl *ipctl,<br>       u32 index)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctl = ipctl-&gt;</span>pctl;<br>struct function_desc *func;<br>struct group_desc *grp;<br>const char **group_names;<br>u32 i;<br><br><span class="hljs-function"><span class="hljs-title">dev_dbg</span>(pctl-&gt;</span>dev, <span class="hljs-string">&quot;parse function(%d): %pOFn\n&quot;</span>, index, np);<br><br>func = pinmux_generic_get_function(pctl, index);<br><span class="hljs-keyword">if</span> (!func)<br>return -EINVAL;<br><br><span class="hljs-comment">/* Initialise function */</span><br><span class="hljs-comment">/* 设置为设备树 function 节点名 */</span><br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">func</span>.<span class="hljs-keyword">name</span> = np-&gt;</span><span class="hljs-keyword">name</span>;<br><span class="hljs-comment">/*  该 function 下有几个 group */</span><br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span>func.ngroups = of_get_child_count(np);<br><span class="hljs-function"><span class="hljs-title">if</span> (func-&gt;</span>func.ngroups == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-function"><span class="hljs-title">dev_info</span>(ipctl-&gt;</span>dev, <span class="hljs-string">&quot;no groups defined in %pOF\n&quot;</span>, np);<br>return -EINVAL;<br>&#125;<br><span class="hljs-comment">/* 分配 group 名称数组，稍后填入所有 group 的名字 */</span><br><span class="hljs-function"><span class="hljs-title">group_names</span> = devm_kcalloc(ipctl-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, func-&gt;</span>func.ngroups,<br>   <span class="hljs-function"><span class="hljs-title">sizeof</span>(*func-&gt;</span>func.groups), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!group_names)<br>return -ENOMEM;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 将每个子 group 的名字填入 groups 数组，用于 framework 调用 pinmux_enable_setting() 时识别 group */</span><br>for_each_child_of_node_scoped(np, child)<br><span class="hljs-function"><span class="hljs-title">group_names</span>[i++] = child-&gt;</span><span class="hljs-keyword">name</span>;<br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span>func.groups = group_names;<br><br>i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*  遍历每个 group，注册到 pinctrl */</span><br>for_each_child_of_node_scoped(np, child) &#123;<br><span class="hljs-function"><span class="hljs-title">grp</span> = devm_kzalloc(ipctl-&gt;</span>dev, sizeof(*grp), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!grp)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">mutex_lock</span>(&amp;ipctl-&gt;</span>mutex);<br><span class="hljs-function"><span class="hljs-title">radix_tree_insert</span>(&amp;pctl-&gt;</span>pin_group_tree,<br>  <span class="hljs-function"><span class="hljs-title">ipctl</span>-&gt;</span>group_index++, grp);<br><span class="hljs-function"><span class="hljs-title">mutex_unlock</span>(&amp;ipctl-&gt;</span>mutex);<br><span class="hljs-comment">/* 进一步解析 fsl,pins 属性 */</span><br>imx_pinctrl_parse_groups(child, grp, ipctl, i++);<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个 function 都会解析成一个 function_desc 结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">function_desc</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinfunction</span> func;<br><span class="hljs-type">void</span> *data;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinfunction</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> *groups;<br><span class="hljs-type">size_t</span> ngroups;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再通过 imx_pinctrl_parse_groups() 将每个group 解析为一个 group_desc 结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">group_desc</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pingroup</span> grp;<br><span class="hljs-type">void</span> *data;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pingroup</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pins;<br><span class="hljs-type">size_t</span> npins;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进入imx_pinctrl_parse_groups()</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">imx_pinctrl_parse_groups</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> group_desc *grp,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> imx_pinctrl *ipctl,</span></span><br><span class="hljs-params"><span class="hljs-function">    u32 index)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl_soc_info</span> *info = ipctl-&gt;info;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pin</span> *pin;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pins;<br><span class="hljs-type">int</span> size, pin_size;<br><span class="hljs-type">const</span> __be32 *list;<br><span class="hljs-type">int</span> i;<br>...<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; grp-&gt;grp.npins; i++) &#123;<br>    pin = &amp;((<span class="hljs-keyword">struct</span> imx_pin *)(grp-&gt;data))[i];<br>    <span class="hljs-keyword">if</span> (info-&gt;flags &amp; IMX_USE_SCU)<br>        info-&gt;<span class="hljs-built_in">imx_pinctrl_parse_pin</span>(ipctl, &amp;pins[i], pin, &amp;list);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">/* 解析单个引脚 */</span><br>        <span class="hljs-built_in">imx_pinctrl_parse_pin_mmio</span>(ipctl, &amp;pins[i], pin, &amp;list, np);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里又出现一个 struct imx_pin ,因为不管这一组group里有多少个pin，最终都是一个一个来解析的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin</span> &#123;<br>unsigned int pin;<br><span class="hljs-built_in">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin_mmio</span> mmio;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin_scu</span> scu;<br>&#125; conf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进入 imx_pinctrl_parse_pin_mmio()</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void imx_pinctrl_parse_pin_mmio(struct imx_pinctrl *ipctl,<br>       unsigned int *pin_id, struct imx_pin *pin,<br>       const __be32 **list_p,<br>       struct device_node *np)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">const</span> struct imx_pinctrl_soc_info *info = ipctl-&gt;</span>info;<br><span class="hljs-function"><span class="hljs-title">struct</span> imx_pin_mmio *pin_mmio = &amp;pin-&gt;</span>conf.mmio;<br>struct imx_pin_reg *pin_reg;<br>const __be32 *list = *list_p;<br>u32 mux_reg, conf_reg;<br>u32 config;<br><br>mux_reg = be32_to_cpu(*list++);<br><br><span class="hljs-function"><span class="hljs-title">if</span> (!(info-&gt;</span>flags &amp; ZERO_OFFSET_VALID) &amp;&amp; !mux_reg)<br>mux_reg = -<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-title">if</span> (info-&gt;</span>flags &amp; SHARE_MUX_CONF_REG) &#123;<br>conf_reg = mux_reg;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>conf_reg = be32_to_cpu(*list++);<br><span class="hljs-keyword">if</span> (!conf_reg)<br>conf_reg = -<span class="hljs-number">1</span>;<br>&#125;<br><br>*pin_id = (mux_reg != -<span class="hljs-number">1</span>) ? mux_reg / <span class="hljs-number">4</span> : conf_reg / <span class="hljs-number">4</span>;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span> = &amp;ipctl-&gt;</span>pin_regs[*pin_id];<br><span class="hljs-function"><span class="hljs-title">pin</span>-&gt;</span>pin = *pin_id;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span>-&gt;</span>mux_reg = mux_reg;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span>-&gt;</span>conf_reg = conf_reg;<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>input_reg = be32_to_cpu(*list++);<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>mux_mode = be32_to_cpu(*list++);<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>input_val = be32_to_cpu(*list++);<br><br>config = be32_to_cpu(*list++);<br><br><span class="hljs-comment">/* SION bit is in mux register */</span><br><span class="hljs-keyword">if</span> (config &amp; IMX_PAD_SION)<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>mux_mode |= IOMUXC_CONFIG_SION;<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>config = config &amp; ~IMX_PAD_SION;<br><br>*list_p = list;<br><br><span class="hljs-function"><span class="hljs-title">dev_dbg</span>(ipctl-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, &quot;%s: 0x%x 0x%08lx&quot;, info-&gt;</span>pins[*pin_id].<span class="hljs-keyword">name</span>,<br>     <span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">mux_mode</span>, pin_mmio-&gt;</span>config);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以清楚的看到，就是根据设备树的信息来记录寄存器的值，这些信息到保存到了 struct imx_pin_mmio 里。</p><h2 id="三、pinctrl-cliend使用过程"><a href="#三、pinctrl-cliend使用过程" class="headerlink" title="三、pinctrl cliend使用过程"></a>三、pinctrl cliend使用过程</h2><p>只要它是一个设备，那么就会和一个相对应的驱动去匹配，在匹配之前会调用一个 really_probe().</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">really_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-comment">/* If using pinctrl, bind pins now before probing */</span><br>ret = <span class="hljs-built_in">pinctrl_bind_pins</span>(dev);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinctrl_bind_pins(struct device *dev)<br>&#123;<br><span class="hljs-comment">/* 上面提到的map to setting */</span><br><span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p = devm_pinctrl_get(dev);              &lt;------------------------------<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p)) &#123;<br>dev_dbg(dev, <span class="hljs-string">&quot;no pinctrl handle\n&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">ret</span> = PTR_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p);<br>goto cleanup_alloc;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">init_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p, <br>PINCTRL_STATE_INIT);<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state)) &#123;<br><span class="hljs-comment">/* Not supplying this state is perfectly legal */</span><br>dev_dbg(dev, <span class="hljs-string">&quot;no init pinctrl state\n&quot;</span>);<br><br><span class="hljs-comment">/* 需要在转换之后去使用 */</span><br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p,&lt;------------------------------<br>   <span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>default_state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">p</span>, dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state);<br>&#125;<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 pinctrl_select_state()</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">pinctrl_select_state</span>()</span><br><span class="hljs-function"><span class="hljs-title">pinctrl_commit_state</span>()</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)<br>&#123;<br>...<br><span class="hljs-comment">/* Apply all the settings for the new state - pinmux first */</span><br>list_for_each_entry(<span class="hljs-keyword">setting</span>, &amp;state-&gt;settings, node) &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">setting</span>-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = pinmux_enable_setting(<span class="hljs-keyword">setting</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-literal">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/* Apply all the settings for the new state - pinconf after */</span><br>list_for_each_entry(<span class="hljs-keyword">setting</span>, &amp;state-&gt;settings, node) &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">setting</span>-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = pinconf_apply_setting(<span class="hljs-keyword">setting</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-literal">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个宏定义在哪里被设置的呢？</p><p>就是在最开始的 dt_node_to_map()里</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">static</span> int imx_dt_node_to_map(struct pinctrl_dev *pctldev,<br>struct device_node *np,<br>struct pinctrl_map **map, unsigned *num_maps)<br>&#123;<br>...<br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">type</span> = <span class="hljs-type">PIN_MAP_TYPE_MUX_GROUP</span>;</span><br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">data</span>.mux.function = parent-&gt;name;</span><br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">data</span>.mux.group = np-&gt;name;</span><br>of_node_put(parent);<br><br>    new_map[j].<span class="hljs-class"><span class="hljs-keyword">type</span> = <span class="hljs-type">PIN_MAP_TYPE_CONFIGS_PIN</span>;</span><br>    new_map[j].<span class="hljs-class"><span class="hljs-keyword">data</span>.configs.group_or_pin =</span><br>    pin_get_name(pctldev, pin-&gt;pin);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于MainLine Kernel的GPIO子系统分析</title>
    <link href="/2025/05/03/GPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/05/03/GPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、层次与数据结构"><a href="#一、层次与数据结构" class="headerlink" title="一、层次与数据结构"></a>一、层次与数据结构</h2><p>GPIO子系统主要的几个数据结构：</p><p>struct gpio_chip {}；</p><p>struct gpio_device {}；</p><p>struct gpio_desc {}；</p><p>对于一个GPIO Cnotroller ,都有相对应的一个 gpio_chip结构体，通过其内部的函数指针最终来操作硬件。</p><p>struct gpio_chip定义如下 include\linux\gpio\driver.h</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*label;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span>*gpiodev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>*parent;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwnode_handle</span>*fwnode;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span>*owner;<br><br><span class="hljs-built_in">int</span>(*request)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">void</span>(*free)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*get_direction)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*direction_input)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*direction_output)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">int</span>(*get)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*get_multiple)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">void</span>(*set)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">void</span>(*set_multiple)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">int</span>(*set_rv)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset,<br>  <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">int</span>(*set_multiple_rv)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">int</span>(*set_config)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> config);<br><span class="hljs-built_in">int</span>(*to_irq)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br>..........<br><br><span class="hljs-type">int</span>base;<br>u16ngpio;<br>u16offset;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*<span class="hljs-type">const</span> *names;<br><span class="hljs-type">bool</span>can_sleep;<br></code></pre></td></tr></table></figure><p>在驱动里定义并初始化一个gpio_chip，使用 gpiochip_add_data()注册。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xl">#define gpiochip_add_data(gc, <span class="hljs-keyword">data</span>) (&#123;\<br>static struct lock_class_key lock_key;\<br>static struct lock_class_key request_key;  \<br>gpiochip_add_data_with_key(gc, <span class="hljs-keyword">data</span>, &amp;lock_key, \       &lt;-----实际调用函数<br>   &amp;request_key);  \<br>&#125;)<br><br>************<br>************<br>gpiochip_add_data_with_key(gc, <span class="hljs-keyword">data</span>, &amp;lock_key, <br>               &amp;request_key)<br> &#123;<br> ........<br> <br> <span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>dev.type = &amp;gpio_dev_type;<br><span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>dev.bus = &amp;gpio_bus_type;<br><br><span class="hljs-comment">/* gdev 绑定 gpio_device */</span><br><span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>.parent = gc-&gt;</span>parent;<br><span class="hljs-function"><span class="hljs-title">rcu_assign_pointer</span>(gdev-&gt;</span>chip, gc);<br><span class="hljs-comment">/* 反向绑定 */</span><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>gpiodev = gdev;<br>gpiochip_set_data(gc, <span class="hljs-keyword">data</span>);<br> <br> ........<br> <br>    <span class="hljs-function"><span class="hljs-title">base</span> = gc-&gt;</span>base;<br>            <span class="hljs-keyword">if</span> (base &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">/* 自动分配 */</span><br>                <span class="hljs-function"><span class="hljs-title">base</span> = gpiochip_find_base_unlocked(gc-&gt;</span>ngpio);<br>                <span class="hljs-keyword">if</span> (base &lt; <span class="hljs-number">0</span>) &#123;<br>                    ret = base;<br>                    base = <span class="hljs-number">0</span>;<br>                    goto err_free_label;<br>                &#125;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * <span class="hljs-doctag">TODO:</span> it should not be necessary to reflect the</span><br><span class="hljs-comment">                 * assigned base outside of the GPIO subsystem. Go over</span><br><span class="hljs-comment">                 * drivers and see if anyone makes use of this, else</span><br><span class="hljs-comment">                 * drop this and assign a poison instead.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>base = base;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">dev_warn</span>(&amp;gdev-&gt;</span>dev,<br>                     <span class="hljs-string">&quot;Static allocation of GPIO base is deprecated, use dynamic allocation.\n&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>base = base;<br><span class="hljs-comment">/* 添加到链表 */</span><br>            ret = gpiodev_add_to_list_unlocked(gdev);<br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                chip_err(gc, <span class="hljs-string">&quot;GPIO integer space overlap, cannot add chip\n&quot;</span>);<br>                goto err_free_label;<br>            &#125;<br>            ......<br>&#125;<br></code></pre></td></tr></table></figure><p>其中比较关键的是</p><p>​       gdev-&gt;dev.parent &#x3D; gc-&gt;parent;<br>​rcu_assign_pointer(gdev-&gt;chip, gc);<br>​&#x2F;* 反向绑定 *&#x2F;<br>​gc-&gt;gpiodev &#x3D; gdev;</p><p>实现了gpio_chip &lt;——-&gt; gpio_device 的双向绑定。</p><p>我们可以看到，这个函数在初始化完这个结构体后，<code>piodev_add_to_list_unlocked</code>  并把它加入全局链表 gpio_devices，正式注册到系统中供其他子系统（比如 pinctrl、IRQ、设备树解析等）使用。</p><h3 id="问：那么全局链表-gpio-devices-是干嘛的？"><a href="#问：那么全局链表-gpio-devices-是干嘛的？" class="headerlink" title="问：那么全局链表 gpio_devices 是干嘛的？"></a>问：那么全局链表 <code>gpio_devices</code> 是干嘛的？</h3><p>这是所有注册到内核的 GPIO 控制器的“数据库”，很多操作都会遍历它，比如：</p><p>1.用户态访问 <code>/sys/class/gpio/</code></p><p>2.设备树中 <code>gpio = &lt;&amp;gpioX ...&gt;</code> 时查找控制器</p><p>3.子系统（如 <code>pinctrl</code>, <code>irqchip</code>）查找 GPIO 资源</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">gpio_devices 里存的是所有注册的 gpio_device（每个 controller 一份）；<br><br>每个 gpio_device 管理一个 <span class="hljs-keyword">desc</span> 数组；<br><br>查找 GPIO 时，从dtb → 找 gpio controller → 找 <span class="hljs-keyword">desc</span>[<span class="hljs-keyword">offset</span>]<br></code></pre></td></tr></table></figure><h2 id="二、函数分析"><a href="#二、函数分析" class="headerlink" title="二、函数分析"></a>二、函数分析</h2><p>我们在分配GPIO资源的时候一般有两种方法，第一种是传统方法，自己在驱动手动实现一个gpio_request()gpio_direction_input()等，另一种则是使用dtb来指定好引脚信息，通过platfrom_device解析后，系统自动gpio_request() gpio_direction_input()…….。</p><h3 id="1-首先是gpiod-get"><a href="#1-首先是gpiod-get" class="headerlink" title="1.首先是gpiod_get()"></a>1.首先是gpiod_get()</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * gpiod_get - obtain a GPIO for a given GPIO function</span><br><span class="hljs-comment"> * @dev:GPIO consumer, can be NULL for system-global GPIOs</span><br><span class="hljs-comment"> * @con_id:function within the GPIO consumer</span><br><span class="hljs-comment"> * @flags:optional GPIO initialization flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns:</span><br><span class="hljs-comment"> * The GPIO descriptor corresponding to the function @con_id of device</span><br><span class="hljs-comment"> * dev, -ENOENT if no GPIO has been assigned to the requested function, or</span><br><span class="hljs-comment"> * another IS_ERR() code if an error occurred while trying to acquire the GPIO.</span><br><span class="hljs-comment"> */</span><br>struct gpio_desc *__must_check <span class="hljs-built_in">gpiod_get</span>(struct device *dev, const char *con_id,<br> enum gpiod_flags flags)<br>&#123;<br>return <span class="hljs-built_in">gpiod_get_index</span>(dev, con_id, <span class="hljs-number">0</span>, flags);<br>&#125;<br><span class="hljs-built_in">EXPORT_SYMBOL_GPL</span>(gpiod_get);<br></code></pre></td></tr></table></figure><h3 id="2-gpiod-get-—-gpiod-get-index"><a href="#2-gpiod-get-—-gpiod-get-index" class="headerlink" title="2.gpiod_get( )   —-&gt;  gpiod_get_index()"></a>2.gpiod_get( )   —-&gt;  gpiod_get_index()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * gpiod_get_index - obtain a GPIO from a multi-index GPIO function</span><br><span class="hljs-comment"> * @dev:GPIO consumer, can be NULL for system-global GPIOs</span><br><span class="hljs-comment"> * @con_id:function within the GPIO consumer</span><br><span class="hljs-comment"> * @idx:index of the GPIO to obtain in the consumer</span><br><span class="hljs-comment"> * @flags:optional GPIO initialization flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This variant of gpiod_get() allows to access GPIOs other than the first</span><br><span class="hljs-comment"> * defined one for functions that define several GPIOs.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns:</span><br><span class="hljs-comment"> * A valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the</span><br><span class="hljs-comment"> * requested function and/or index, or another IS_ERR() code if an error</span><br><span class="hljs-comment"> * occurred while trying to acquire the GPIO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span> *<span class="hljs-function">__must_check <span class="hljs-title">gpiod_get_index</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">enum</span> gpiod_flags flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwnode_handle</span> *fwnode = dev ? <span class="hljs-built_in">dev_fwnode</span>(dev) : <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *devname = dev ? <span class="hljs-built_in">dev_name</span>(dev) : <span class="hljs-string">&quot;?&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *label = con_id ?: devname;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gpiod_find_and_request</span>(dev, fwnode, con_id, idx, flags, label, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-built_in">EXPORT_SYMBOL_GPL</span>(gpiod_get_index);<br></code></pre></td></tr></table></figure><h3 id="3-—–-gpiod-find-and-request-："><a href="#3-—–-gpiod-find-and-request-：" class="headerlink" title="3,   —–&gt;gpiod_find_and_request()："></a>3,   —–&gt;gpiod_find_and_request()：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs stata">struct gpio_desc *gpiod_find_and_request(struct device *consumer,<br> struct fwnode_handle *fwnode,<br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *con_id,<br> unsigned int idx,<br> enum gpiod_flags flags,<br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">label</span>,<br> bool platform_lookup_allowed)<br>&#123;<br>unsigned long lookupflags = GPIO_LOOKUP_FLAGS_DEFAULT;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = function_name_or_default(con_id);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * scoped_guard() is implemented as a for loop, meaning static</span><br><span class="hljs-comment"> * analyzers will complain about these two not being initialized.</span><br><span class="hljs-comment"> */</span><br>struct gpio_desc *<span class="hljs-keyword">desc</span> = NULL;<br>int <span class="hljs-keyword">ret</span> = 0;<br><br>scoped_guard(srcu, &amp;gpio_devices_srcu) &#123;<br><span class="hljs-comment">/*gpiod_find_by_fwnode 从设备树 (DT) 或 ACPI 中查找该 GPIO 的 gpio_desc。</span><br><span class="hljs-comment"> 利用 con_id 和 idx 来定位某个 label 名下的某个 GPIO。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">desc</span> = gpiod_find_by_fwnode(fwnode, consumer, con_id, idx,<br>    &amp;flags, &amp;lookupflags);<br><span class="hljs-keyword">if</span> (gpiod_not_found(<span class="hljs-keyword">desc</span>) &amp;&amp; platform_lookup_allowed) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Either we are not using DT or ACPI, or their lookup</span><br><span class="hljs-comment"> * did not return a result. In that case, use platform</span><br><span class="hljs-comment"> * lookup as a fallback.</span><br><span class="hljs-comment"> */</span><br>dev_dbg(consumer,<br><span class="hljs-string">&quot;using lookup tables for GPIO lookup\n&quot;</span>);<br><span class="hljs-keyword">desc</span> = gpiod_find(consumer, con_id, idx, &amp;lookupflags);<br>&#125;<br><br><span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-keyword">desc</span>)) &#123;<br>dev_dbg(consumer, <span class="hljs-string">&quot;No GPIO consumer %s found\n&quot;</span>, name);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If a connection label was passed use that, else attempt to use</span><br><span class="hljs-comment"> * the device name as label</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/* 这里就是通过DTB规定好的GPIO引脚，自动申请 */</span><br><span class="hljs-keyword">ret</span> = gpiod_request(<span class="hljs-keyword">desc</span>, <span class="hljs-keyword">label</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>) &#123;<br><span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">ret</span> == -EBUSY &amp;&amp; flags &amp; GPIOD_FLAGS_BIT_NONEXCLUSIVE))<br><span class="hljs-keyword">return</span> ERR_PTR(<span class="hljs-keyword">ret</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This happens when there are several consumers for</span><br><span class="hljs-comment"> * the same GPIO line: we just return here without</span><br><span class="hljs-comment"> * further initialization. It is a bit of a hack.</span><br><span class="hljs-comment"> * This is necessary to support fixed regulators.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">FIXME:</span> Make this more sane and safe.</span><br><span class="hljs-comment"> */</span><br>dev_info(consumer, <span class="hljs-string">&quot;nonexclusive access to GPIO for %s\n&quot;</span>, name);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br><br><span class="hljs-keyword">ret</span> = gpiod_configure_flags(<span class="hljs-keyword">desc</span>, con_id, lookupflags, flags);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> &lt; 0) &#123;<br>gpiod_put(<span class="hljs-keyword">desc</span>);<br>dev_err(consumer, <span class="hljs-string">&quot;setup of GPIO %s failed: %d\n&quot;</span>, name, <span class="hljs-keyword">ret</span>);<br><span class="hljs-keyword">return</span> ERR_PTR(<span class="hljs-keyword">ret</span>);<br>&#125;<br><br>gpiod_line_state_notify(<span class="hljs-keyword">desc</span>, GPIO_V2_LINE_CHANGED_REQUESTED);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这和函数内部实现了解析设备树 gpiod_find_by_fwnode ，引脚申请、标志位设置。</p><h2 id="三、i-mx6ull-probe解析"><a href="#三、i-mx6ull-probe解析" class="headerlink" title="三、i.mx6ull probe解析"></a>三、i.mx6ull probe解析</h2><h3 id="1-打开驱动源码-drivers-gpio-gpio-mxc-c，找到probe函数"><a href="#1-打开驱动源码-drivers-gpio-gpio-mxc-c，找到probe函数" class="headerlink" title="1.打开驱动源码  drivers\gpio\gpio-mxc.c，找到probe函数"></a>1.打开驱动源码  drivers\gpio\gpio-mxc.c，找到probe函数</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int mxc_gpio_probe(struct platform_device *pdev)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *np = pdev-&gt;</span>dev.of_node;<br>struct mxc_gpio_port *port;   <br>int irq_count;<br>int irq_base;<br>int err;<br><br><span class="hljs-function"><span class="hljs-title">port</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(*port), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!port)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span> = &amp;pdev-&gt;</span>dev;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hwdata</span> = device_get_match_data(&amp;pdev-&gt;</span>dev);<br><br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(port-&gt;</span>base))<br><span class="hljs-function"><span class="hljs-title">return</span> PTR_ERR(port-&gt;</span>base);<br>......<br>mxc_update_irq_chained_handler(port, <span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-title">err</span> = bgpio_init(&amp;port-&gt;</span><span class="hljs-function"><span class="hljs-title">gc</span>, &amp;pdev-&gt;</span>dev, <span class="hljs-number">4</span>,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_PSR,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_DR, NULL,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_GDIR, NULL,<br> BGPIOF_READ_OUTPUT_REG_SET);<br><span class="hljs-keyword">if</span> (err)<br>goto out_bgio;<br>.......<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.request = mxc_gpio_request;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.free = mxc_gpio_free;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.to_irq = mxc_gpio_to_irq;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.base = of_alias_get_id(np, <span class="hljs-string">&quot;gpio&quot;</span>) * <span class="hljs-number">32</span>;<br><br><span class="hljs-function"><span class="hljs-title">err</span> = devm_gpiochip_add_data(&amp;pdev-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, &amp;port-&gt;</span>gc, port);<br><span class="hljs-keyword">if</span> (err)<br>goto out_bgio;<br><br><span class="hljs-function"><span class="hljs-title">irq_base</span> = devm_irq_alloc_descs(&amp;pdev-&gt;</span>dev, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, numa_node_id());<br><span class="hljs-keyword">if</span> (irq_base &lt; <span class="hljs-number">0</span>) &#123;<br>err = irq_base;<br>goto out_bgio;<br>&#125;<br>......<br><span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;port-&gt;</span>node, &amp;mxc_gpio_ports);<br>return err;<br>&#125;<br><br>**************************<br>struct mxc_gpio_port &#123;<br>struct list_head node;<br>void __iomem *base;<br>struct clk *clk;<br>int irq;<br>int irq_high;<br>void (*mx_irq_handler)(struct irq_desc *desc);<br>struct irq_domain *domain;<br>struct gpio_chip gc;<br>.....<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到这个函数主要就是在对一个gpio_chip进行分配、设置、注册。gpio_chip 在struct mxc_gpio_port *port;   结构体中。</p><h3 id="2-bgpio-init"><a href="#2-bgpio-init" class="headerlink" title="2.bgpio_init()"></a>2.bgpio_init()</h3><p>重点关注probe里的 bgpio_init 函数，我们首先看传的参数： port-&gt;base + GPIO_PSR, port-&gt;base + GPIO_DR, NULL, port-&gt;base + GPIO_GDIR, NULL,这几个参数就是一些寄存器的虚拟地址，分别是状态寄存器，数据寄存器，方向寄存器.</p><p>我们再进入函数内部：核心函数bgpio_setup_io</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int bgpio_init(struct gpio_chip *<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> struct device *dev<span class="hljs-punctuation">,</span><br>       unsigned long sz<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dat<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *set<span class="hljs-punctuation">,</span><br>       <span class="hljs-type">void</span> __iomem *clr<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dirout<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dirin<span class="hljs-punctuation">,</span><br>       unsigned long flags)<br>&#123;<br>int <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>raw_spin_lock_init(&amp;<span class="hljs-keyword">gc</span>-&gt;bgpio_lock)<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;parent <span class="hljs-operator">=</span> dev<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;<span class="hljs-type">label</span> <span class="hljs-operator">=</span> dev_name(dev)<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;base <span class="hljs-operator">=</span> <span class="hljs-number">-1</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;request <span class="hljs-operator">=</span> bgpio_request<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;be_bits <span class="hljs-operator">=</span> !!(flags &amp; BGPIOF_BIG_ENDIAN)<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">ret</span> <span class="hljs-operator">=</span> gpiochip_get_ngpios(<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> dev)<span class="hljs-comment">;</span><br>if (<span class="hljs-keyword">ret</span>)<br><span class="hljs-keyword">gc</span>-&gt;ngpio <span class="hljs-operator">=</span> <span class="hljs-keyword">gc</span>-&gt;bgpio_bits<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">ret</span> <span class="hljs-operator">=</span> bgpio_setup_io(<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> dat<span class="hljs-punctuation">,</span> set<span class="hljs-punctuation">,</span> clr<span class="hljs-punctuation">,</span> flags)<span class="hljs-comment">;</span><br>if (<span class="hljs-keyword">ret</span>)<br>return <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>return <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-bgpio-setup-io"><a href="#3-bgpio-setup-io" class="headerlink" title="3.bgpio_setup_io()"></a>3.bgpio_setup_io()</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int bgpio_setup_io(struct gpio_chip *gc,<br>  void __iomem *dat,<br>  void __iomem *set,<br>  void __iomem *clr,<br>  unsigned long flags)<br>&#123;<br><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_dat = dat;<br><span class="hljs-function"><span class="hljs-title">if</span> (!gc-&gt;</span>reg_dat)<br>return -EINVAL;<br><br><span class="hljs-keyword">if</span> (set &amp;&amp; clr) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_set = set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_clr = clr;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_with_clear;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple_with_clear;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (set &amp;&amp; !clr) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_set = set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple_set;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; BGPIOF_NO_OUTPUT) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_none;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = NULL;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!(flags &amp; BGPIOF_UNREADABLE_REG_SET) &amp;&amp;<br>    (flags &amp; BGPIOF_READ_OUTPUT_REG_SET)) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get = bgpio_get_set;<br><span class="hljs-function"><span class="hljs-title">if</span> (!gc-&gt;</span>be_bits)<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_set_multiple;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We deliberately avoid assigning the -&gt;get_multiple() call</span><br><span class="hljs-comment"> * for big endian mirrored registers which are ALSO reflecting</span><br><span class="hljs-comment"> * their value in the set register when used as output. It is</span><br><span class="hljs-comment"> * simply too much complexity, let the GPIO core fall back to</span><br><span class="hljs-comment"> * reading each line individually in that fringe case.</span><br><span class="hljs-comment"> */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get = bgpio_get;<br><span class="hljs-function"><span class="hljs-title">if</span> (gc-&gt;</span>be_bits)<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_multiple_be;<br><span class="hljs-keyword">else</span><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_multiple;<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它给我们去绑定了一些设置函数，这些函数都不需要我们去实现。这就是我们在驱动层调用gpiod_set最终执行到的地方。</p><p>这个功能都是由bgpio_init（）提供的，这个函数是 <strong>Linux GPIO 子系统提供的一个通用框架函数</strong>，用于简化<strong>标准寄存器布局的 GPIO 控制器驱动编写</strong>。在bgpio_init（）之后赋值的部分是 <strong>针对特定平台额外补充的能力函数</strong>，比如request&#x2F;free&#x2F;to_irq….</p><p>接着我们再次回到probe函数，有一个注册函数 err &#x3D; devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;port-&gt;gc, port);</p><p>我们跳进去查看：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define devm_gpiochip_add_data(dev, gc, data) (&#123; \</span><br><span class="hljs-keyword">static</span> struct lock_class_key lock_key;<span class="hljs-string">\</span><br><span class="hljs-keyword">static</span> struct lock_class_key request_key;  <span class="hljs-string">\</span><br>devm_gpiochip_add_data_with_key(dev, gc, data, &amp;lock_key, <span class="hljs-string">\</span><br>   &amp;request_key);  <span class="hljs-string">\</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到这里调用的就是我们之前分析过的 gpio_chip注册的那一套流程 devm_gpiochip_add_data_with_key()；</p><p>到此关于GPIO子系统的内部实现就简单分析到此。</p><p>未完……….</p><h2 id="四、platfrom-device-、platfrom-driver-match-过程"><a href="#四、platfrom-device-、platfrom-driver-match-过程" class="headerlink" title="四、platfrom_device 、platfrom_driver match 过程"></a>四、platfrom_device 、platfrom_driver match 过程</h2><h3 id="1-platfrom-device-注册过程"><a href="#1-platfrom-device-注册过程" class="headerlink" title="1.platfrom_device 注册过程"></a>1.platfrom_device 注册过程</h3><p>platfrom_device 注册的方式有两种：第一种是手动注册，用 <code>platform_device_register()</code> 自己注册设备，另一种则是设备树生成，系统启动时，<code>of_platform_populate()</code> 扫描设备树，发现 <code>compatible</code> 字段的节点就注册成 <code>platform_device</code>。</p><p>首先分析手动注册：进入platform_device_register（）；</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">int platform_device_register(struct platform_device *pdev)<br>&#123;<br>    device_initialize(&amp;pdev-&gt;dev);###初始化设备结构体 pdev-&gt;dev，清除未初始化字段，确保设备结构体状态正确。<br>    setup_pdev_dma_masks(pdev);<br>    return platform_device_add(pdev);     ###将驱动注册到内核中<br>&#125;<br></code></pre></td></tr></table></figure><p>依次进入platform_device_add（）—&gt;device_add()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">platform_device_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *dev = &amp;pdev-&gt;dev;<br>u32 i;<br><span class="hljs-type">int</span> ret;<br>...<br>ret = <span class="hljs-built_in">device_add</span>(dev);         &lt;----------- 添加到设备总线 <br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> failed;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>device_add()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">device_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">subsys_private</span> *sp;<br>...<br><span class="hljs-comment">/* notify platform of device entry */</span><br><span class="hljs-built_in">device_platform_notify</span>(dev);<br><br>error = <span class="hljs-built_in">bus_add_device</span>(dev);  &lt;-----将device加入到对应的 <span class="hljs-function">bus</span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">goto</span> BusError</span>;<br>.........<br>&#125;<br></code></pre></td></tr></table></figure><p>设备一旦添加到总线上，系统就会自动调用总线的匹配机制，找到与之匹配的驱动，进而调用驱动的 <code>.probe()</code> 函数。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs subunit">int bus_add_device(struct device *dev)<br>&#123;<br>pr_debug(&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;, sp-&gt;bus-&gt;name, dev_name(dev));<br><br><span class="hljs-keyword">error </span>= device_add_groups(dev, sp-&gt;bus-&gt;dev_groups);<br>if (error)<br>goto out_put;<br><br><span class="hljs-keyword">error </span>= sysfs_create_link(&amp;sp-&gt;devices_kset-&gt;kobj, &amp;dev-&gt;kobj, dev_name(dev));<br>if (error)<br>goto out_groups;<br><br><span class="hljs-keyword">error </span>= sysfs_create_link(&amp;dev-&gt;kobj, &amp;sp-&gt;subsys.kobj, &quot;subsystem&quot;);<br>if (error)<br>goto out_subsys;<br><br>klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;sp-&gt;klist_devices);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">device_add</span>()</span><br> └── <span class="hljs-function"><span class="hljs-title">bus_add_device</span>()</span><br>      └── <span class="hljs-function"><span class="hljs-title">bus_probe_device</span>()</span><br>           └── <span class="hljs-function"><span class="hljs-title">device_initial_probe</span>()</span><br>                └── <span class="hljs-function"><span class="hljs-title">driver_match_device</span>()</span><br>                     └── <span class="hljs-function"><span class="hljs-title">probe</span>()</span><br></code></pre></td></tr></table></figure><h3 id="2-设备树转换platfrom-device"><a href="#2-设备树转换platfrom-device" class="headerlink" title="2.设备树转换platfrom_device"></a>2.设备树转换platfrom_device</h3><h3 id="3-platfrom-driver-注册过程"><a href="#3-platfrom-driver-注册过程" class="headerlink" title="3.platfrom_driver 注册过程"></a>3.platfrom_driver 注册过程</h3><p>详细讲述了platfrom_driver   .probe函数是如何调用的。</p><p>但是二者之间稍有不同。暂时没有深入研究….（二者间.probe调用方式和时间）</p><h2 id="五、GPIO-与Pinctrl-的关联"><a href="#五、GPIO-与Pinctrl-的关联" class="headerlink" title="五、GPIO 与Pinctrl 的关联"></a>五、GPIO 与Pinctrl 的关联</h2><p>在硬件上并没有Pinctrl这个模块，它是由软件虚拟出来的一个概念，很多时候Pinctrl的功能都是由GPIO控制器来完成的,所以说他们是密切相关的。</p><p>有时候在去操作一个gpio引脚时，明明没有把它通过pinctrl配置为gpio模式，但还是能去使用，这是因为在硬件上gpio引脚都是连接在gpio控制器上的，所以默认就是gpio模式。</p><h3 id="1-gpio与pinctrl的映射关系"><a href="#1-gpio与pinctrl的映射关系" class="headerlink" title="1.gpio与pinctrl的映射关系"></a>1.gpio与pinctrl的映射关系</h3><p>pinctrl_desc 和 gpio_device结构体:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_desc</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> *pins;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_ops</span> *pctlops;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinmux_ops</span> *pmxops;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinconf_ops</span> *confops;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_custom_params;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinconf_generic_params</span> *custom_params;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pin_config_item</span> *custom_conf_items;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">bool</span> link_consumers;<br>&#125;;<br>*******************************************************************<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>dev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span>chrdev;<br><span class="hljs-type">int</span>id;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>*mockdev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span>*owner;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> __rcu*chip;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>*descs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*valid_mask;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">srcu_struct</span>desc_srcu;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>base;<br>u16ngpio;<br><span class="hljs-type">bool</span>can_sleep;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*label;<br><span class="hljs-type">void</span>*data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>        list;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">raw_notifier_head</span> line_state_notifier;<br><span class="hljs-type">rwlock_t</span>line_state_lock;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">workqueue_struct</span>*line_state_wq;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">blocking_notifier_head</span> device_notifier;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">srcu_struct</span>srcu;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>先说结果，struct gpio_device里有一个struct gpio_desc *desc结构体，我们知道gpio_desc 就是某一个pin的描述符，我们说的映射关系就是如何将  struct gpio_desc *desc ——&gt; pinctrl_pin_desc *pins,然后由 pinctrl_desc 里的struct pinmux_ops *pmxops提供的reset（）、gpio_set_direction（）函数去操作设置gpio pin。</p><p>需要研究的就是这个映射过程。</p><p>设备树方面,以gpio1为例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">gpio1: gpio<span class="hljs-meta">@209c000</span> &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x0209c000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;</span>,<br>     <span class="hljs-variable">&lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;</span>;<br>clocks = <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_GPIO1&gt;</span>;<br>gpio-controller;<br><span class="hljs-comment">#gpio-cells = &lt;2&gt;;</span><br>interrupt-controller;<br><span class="hljs-comment">#interrupt-cells = &lt;2&gt;;</span><br>gpio-ranges = <span class="hljs-variable">&lt;&amp;iomuxc  0 23 10&gt;</span>, <span class="hljs-variable">&lt;&amp;iomuxc 10 17 6&gt;</span>,<br>      <span class="hljs-variable">&lt;&amp;iomuxc 16 33 16&gt;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到有一个gpio-ranges &#x3D; &lt;&amp;iomuxc  0 23 10&gt;, &lt;&amp;iomuxc 10 17 6&gt;,<br>      &lt;&amp;iomuxc 16 33 16&gt;; 属性：</p><p>&lt;&amp;iomuxc  0 23 10&gt; ：gpio1的第0个引脚要映射到pinctrl里的第23个引脚上，有10个引脚，可以看出一共有32个引脚。</p><p>那么在代码里怎么去表示呢？有两个结构体：gpio_pin_range    pinctrl_gpio_range</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_pin_range</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> node;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *pctldev;     &lt;-------<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_gpio_range</span> range;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_gpio_range</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> node;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> base;         &lt;-------<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pin_base;     &lt;-------<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;   <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> *pins;   &lt;--------<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> *gc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最终就是映射到 pctldev 里，怎么映射？使用 range 表示，base表示GPIO系统中的引脚编号（注意，是整个GPIO系统，而不是某一个GPIO控制器，如gpio1_0 在这里可能就是 100，gpio1_1 在这里可能就是 101）。</p><p>pin_base则是pinctrl里的引脚编号（0~xxx）,pins表示引脚个数。</p><p>从gpiod_get()入手：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">gpiod<span class="hljs-emphasis">_get</span><br><span class="hljs-emphasis">gpiod_get_index</span><br><span class="hljs-emphasis">gpiod_find_and_request</span><br><span class="hljs-emphasis">gpiod_request</span><br><span class="hljs-emphasis">gpiod_request_</span>commit<br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gpiod_request_commit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gpio_desc *desc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-built_in">CLASS</span>(gpio_chip_guard, guard)(desc);<br><span class="hljs-keyword">if</span> (guard.gc-&gt;request) &#123;<br>ret = guard.gc-&gt;<span class="hljs-built_in">request</span>(guard.gc, offset);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>ret = -EBADE;<br>...<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip_guard</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span> *gdev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> *gc;<br><span class="hljs-type">int</span> idx;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到就是我们如上所说最终调用的就是 gpio_chip 里的 request 函数。（其实这里和上面分析的gpiod_get（）差不多，只是分析的不是同一个功能）。</p><p>在上面分析 device driver match 的过程中，gpio-mxc.c 里的probe函数有这么一段：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.request = mxc_gpio_request;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.free = mxc_gpio_free;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.to_irq = mxc_gpio_to_irq;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.base = of_alias_get_id(np, <span class="hljs-string">&quot;gpio&quot;</span>) * <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure><p>可有看到这里设置了一个 mxc_gpio_request函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">mxc_gpio_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gpio_chip *chip, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = <span class="hljs-built_in">gpiochip_generic_request</span>(chip, offset);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pm_runtime_resume_and_get</span>(chip-&gt;parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个通用的gpio_request函数</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean">int gpiochip_generic_request(struct gpio_chip *gc, unsigned int offset)<br>&#123;<br>#ifdef CONFIG_PINCTRL<br><span class="hljs-keyword">if</span> (list_empty(&amp;gc-&gt;gpiodev-&gt;pin_ranges))<br>return <span class="hljs-number">0</span>;<br>#endif<br><br>return pinctrl_gpio_request(gc, offset);    &lt;------<br>&#125;<br><br>#########################################################<br><br>int pinctrl_gpio_request(struct gpio_chip *gc, unsigned int offset)<br>&#123;<br>struct pinctrl_gpio_range *range;<br>struct pinctrl_dev *pctldev;<br>int ret, pin;<br><br>ret = pinctrl_get_device_gpio_range(gc, offset, &amp;pctldev, &amp;range);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-keyword">if</span> (pinctrl_ready_for_gpio_range(gc, offset))<br>ret = <span class="hljs-number">0</span>;<br>return ret;<br>&#125;<br><br>mutex_lock(&amp;pctldev-&gt;mutex);<br><br><span class="hljs-comment">/* Convert to the pin controllers number space */</span><br>pin = gpio_to_pin(range, gc, offset);<br><br>ret = pinmux_request_gpio(pctldev, range, pin, gc-&gt;base + offset);<br><br>mutex_unlock(&amp;pctldev-&gt;mutex);<br><br>return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>pinctrl_gpio_request()里果然有一个pinctrl_ready_for_gpio_range()函数得到range,再通过gpio_to_pin（）将这个引脚转换为pin controllers number，然后执行pinmux_request_gpio(pctldev, range, pin, gc-&gt;base + offset)（这里从参数可以看出，传入的就是gpio系统的全局编号）。</p><p>再接着往下看，进入 pinmux_request_gpio()</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs clean">int pinmux_request_gpio(struct pinctrl_dev *pctldev,<br>struct pinctrl_gpio_range *range,<br>unsigned int pin, unsigned int gpio)<br>&#123;<br>const char *owner;<br>int ret;<br><br><span class="hljs-comment">/* Conjure some name stating what chip and pin this is taken by */</span><br>owner = kasprintf(GFP_KERNEL, <span class="hljs-string">&quot;%s:%d&quot;</span>, range-&gt;name, gpio);<br><span class="hljs-keyword">if</span> (!owner)<br>return -ENOMEM;<br><br>ret = pin_request(pctldev, pin, owner, range);     &lt;--------<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>kfree(owner);<br><br>return ret;<br>&#125;<br><br><br>#############################################<br><br>static int pin_request(struct pinctrl_dev *pctldev,<br>       int pin, const char *owner,<br>       struct pinctrl_gpio_range *gpio_range)<br>&#123;<br>struct pin_desc *desc;<br>const struct pinmux_ops *ops = pctldev-&gt;desc-&gt;pmxops;<br>int status = -EINVAL;<br>...<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * If there is no kind of request function for the pin we just assume</span><br><span class="hljs-comment"> * we got it by default and proceed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gpio_range &amp;&amp; ops-&gt;gpio_request_enable)<br><span class="hljs-comment">/* This requests and enables a single GPIO pin */</span><br>status = ops-&gt;gpio_request_enable(pctldev, gpio_range, pin);<br>else <span class="hljs-keyword">if</span> (ops-&gt;request)<br>status = ops-&gt;request(pctldev, pin);<br>else<br>status = <span class="hljs-number">0</span>;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>pin_request()里看到，如果 struct pinctrl_gpio_range 里提供了gpio_request_enable、request 函数，就把他设置为gpio功能，如果没有怎什么都不做。</p><p>以上就是大致的映射过程。有不对的地方望指正。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
