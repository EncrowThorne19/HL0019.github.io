<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>I2C Loopback Slave</title>
    <link href="/2025/05/12/I2C%20Loopback%20Slave/"/>
    <url>/2025/05/12/I2C%20Loopback%20Slave/</url>
    
    <content type="html"><![CDATA[<p>1.启用内核的 I2C Slave 功能和 EEPROM 模拟驱动,我是直接修改 .config</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_I2C_SLAVE</span>=y<br><span class="hljs-attr">CONFIG_I2C_SLAVE_EEPROM</span>=y<br></code></pre></td></tr></table></figure><p>（我的i2c-0为主机，i2c-1为从机）</p><p>2.手动添加从机模拟设备节点</p><p>#####(刚开始检测不到设备就是这里出了问题)#####</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-1/new_device<br></code></pre></td></tr></table></figure><p>这会把 EEPROM 从机挂在 I2C-1上，地址是 <code>0x50</code>（常见 EEPROM 地址）。</p><p>但是这里依然会把这个地址为 0x50 的 EEPROM 模拟器挂载上，可以看：出现了1-0050</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@ATK-IMX6U:~# ls /sys/bus/i2c/devices/i2c-<span class="hljs-number">1</span><br><span class="hljs-attribute">1</span>-<span class="hljs-number">001</span>a  <span class="hljs-number">1</span>-<span class="hljs-number">003</span>c  <span class="hljs-number">1</span>-<span class="hljs-number">0050</span>  delete_device  i2c-dev  name  new_device  of_node  power  subsystem  uevent<br></code></pre></td></tr></table></figure><p>按道理说现在就应该进行读写了，但是我执行    i2cdetect -y 1  并没有看到检测到一个模拟设备</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">root@ATK</span><span class="hljs-literal">-</span><span class="hljs-comment">IMX6U:~# i2cdetect</span> <span class="hljs-literal">-</span><span class="hljs-comment">y 1</span><br>     <span class="hljs-comment">0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="hljs-comment">00:</span>          <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">10:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">20:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">30:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">40:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">50:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">60:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">70:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br></code></pre></td></tr></table></figure><p>那么说明问题出在  i2c-slave-eeprom.c 这个文件的  probe 函数里，添加打印信息后也没有从dmesg里看到，可见i2c_slave_eeprom_probe函数压根没有运行，进入文件找到如下</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nix">static const struct i2c_device_id i2c_slave_eeprom_id[] <span class="hljs-operator">=</span> &#123; <br>        &#123; <span class="hljs-string">&quot;slave-24c02&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">2048</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>,  <span class="hljs-number">0</span>) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c02ro&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">2048</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>,  I2C_SLAVE_FLAG_RO) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c32&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">32768</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c32ro&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">32768</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c64&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">65536</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c64ro&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">65536</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c512&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">524288</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16) &#125;,<br>        &#123; <span class="hljs-string">&quot;slave-24c512ro&quot;</span>, I2C_SLAVE_DEVICE_MAGIC(<span class="hljs-number">524288</span> <span class="hljs-symbol">/</span> <span class="hljs-number">8</span>, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) &#125;,<br>        &#123; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看到ID表里哪有eeprom？当然不会匹配，所以将挂载命令换成：（将eeprom换成slave-24c02）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> slave-24c02 0x50 &gt; /sys/bus/i2c/devices/i2c-1/new_device<br></code></pre></td></tr></table></figure><p>执行完成之后，i2c_slave_eeprom_probe运行。</p><p>3.查看设备是否正常</p><p>利用跳线连接后，可以看到</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">root@ATK</span><span class="hljs-literal">-</span><span class="hljs-comment">IMX6U:~# i2cdetect</span> <span class="hljs-literal">-</span><span class="hljs-comment">y 0</span><br>     <span class="hljs-comment">0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="hljs-comment">00:</span>          <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">10:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">20:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">30:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">40:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">50: 50</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">60:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">70:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">root@ATK</span><span class="hljs-literal">-</span><span class="hljs-comment">IMX6U:~# i2cdetect</span> <span class="hljs-literal">-</span><span class="hljs-comment">y 1</span><br>     <span class="hljs-comment">0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="hljs-comment">00:</span>          <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">10:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">20:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">30:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">40:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">50: UU</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">60:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">70:</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><br><br><span class="hljs-comment">UU:表示该地址已经被一个内核驱动占用（在这个 case 中就是 i2c</span><span class="hljs-literal">-</span><span class="hljs-comment">slave</span><span class="hljs-literal">-</span><span class="hljs-comment">eeprom 驱动）。</span><br><span class="hljs-comment">50:上也有一个从设备 0x50，但它没有被内核占用（没有被注册为驱动）。</span><br></code></pre></td></tr></table></figure><p>4.测试写入字节</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">root@ATK-IMX6U:~# i2cset -y <span class="hljs-number">0</span> <span class="hljs-number">0x50</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x02</span>  <span class="hljs-number">0x04</span> <span class="hljs-number">0x05</span> <span class="hljs-number">0x06</span> <span class="hljs-number">0x07</span> <span class="hljs-number">0x08</span> <span class="hljs-number">0x09</span> <span class="hljs-number">0x0A</span> <span class="hljs-number">0x0B</span> <span class="hljs-number">0x0C</span> <span class="hljs-number">0x0D</span> <span class="hljs-number">0x0E</span> <span class="hljs-number">0x0F</span> <span class="hljs-number">0x10</span> i<br>最后i是参数：<br>    c (<span class="hljs-built_in">byte</span>, no value)<br>    b (<span class="hljs-built_in">byte</span> data, <span class="hljs-meta">default</span>)<br>    w (<span class="hljs-built_in">word</span> data)<br>    i (I2C block data)<br>    s (SMBus block data)<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@ATK-IMX6U:~# i2cdump -y <span class="hljs-number">0</span> <span class="hljs-number">0</span>x50<br><span class="hljs-attribute">No</span> size specified (using byte-data access)<br>     <span class="hljs-attribute">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f    <span class="hljs-number">0123456789</span>abcdef<br><span class="hljs-attribute">00</span>: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0</span>f <span class="hljs-number">10</span> ff    ???????????????.<br><span class="hljs-attribute">10</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">20</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">30</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">40</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">50</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">60</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">70</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">80</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">90</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">a0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">b0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">c0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">d0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">e0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br><span class="hljs-attribute">f0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br></code></pre></td></tr></table></figure><p>写入成功。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>imx6ull移植v6.15-rc1主线内核</title>
    <link href="/2025/05/12/imx6ull%E7%A7%BB%E6%A4%8D%E4%B8%BB%E7%BA%BF%E5%86%85%E6%A0%B86.12.0-rc5-dirty/"/>
    <url>/2025/05/12/imx6ull%E7%A7%BB%E6%A4%8D%E4%B8%BB%E7%BA%BF%E5%86%85%E6%A0%B86.12.0-rc5-dirty/</url>
    
    <content type="html"><![CDATA[<h2 id="一、内核下载、配置、编译"><a href="#一、内核下载、配置、编译" class="headerlink" title="一、内核下载、配置、编译"></a>一、内核下载、配置、编译</h2><h3 id="1-内核下载"><a href="#1-内核下载" class="headerlink" title="1.内核下载"></a>1.内核下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --depth=<span class="hljs-number">1</span> --branch v6.<span class="hljs-number">15</span>-rc1 https:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/</span>torvalds/linux.git<br></code></pre></td></tr></table></figure><h3 id="2-交叉编译链"><a href="#2-交叉编译链" class="headerlink" title="2.交叉编译链"></a>2.交叉编译链</h3><p>使用armv7架构的交叉编译工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install gcc-arm-linux-gnueabihf<br><span class="hljs-comment">#装好之后</span><br><span class="hljs-built_in">which</span> arm-linux-gnueabihf-gcc<br></code></pre></td></tr></table></figure><p>出现路径则成功。</p><h3 id="3-内核的配置"><a href="#3-内核的配置" class="headerlink" title="3.内核的配置"></a>3.内核的配置</h3><p>我的开发板是正点原子的imx6ull  mini，使用他们提供的config文件配置内核（imx_v7_mfg_defconfig），文件可以从原子官网获取。</p><p>（1）将imx_v7_mfg_defconfig配置文件复制到6.12.0-rc5-dirty内核目录arch&#x2F;arm&#x2F;configs&#x2F;下,并在内核根目录下并make.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_mfg_defconfig<br><br>❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_mfg_defconfig                                     ─╯<br>  HOSTCC  scripts<span class="hljs-regexp">/basic/</span>fixdep<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>conf.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>confdata.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>expr.o<br>  LEX     scripts<span class="hljs-regexp">/kconfig/</span>lexer.lex.c<br>  YACC    scripts<span class="hljs-regexp">/kconfig/</span>parser.tab.[ch]<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>lexer.lex.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/m</span>enu.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>parser.tab.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>preprocess.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/</span>symbol.o<br>  HOSTCC  scripts<span class="hljs-regexp">/kconfig/u</span>til.o<br>  HOSTLD  scripts<span class="hljs-regexp">/kconfig/</span>conf<br><span class="hljs-comment">#</span><br><span class="hljs-comment"># configuration written to .config</span><br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>（2）因为 I.MX6ULL 是 ARMV7 架构的，因此要屏蔽掉 V6 相关选项，否则后面做驱动实验的时候可能会遇到驱动模块无法加载的情况,在内核根目录下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">❯ cat .config | grep <span class="hljs-string">&#x27;CONFIG_ARCH_MULTI_V6&#x27;</span>                                                                 ─╯<br><span class="hljs-attribute">CONFIG_ARCH_MULTI_V6</span>=y<br><span class="hljs-attribute">CONFIG_ARCH_MULTI_V6_V7</span>=y<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">❯ vim .config <br><span class="hljs-comment"># CONFIG_ARCH_MULTI_V6 is not set  -&gt;如CONFIG_ARCH_MULTI_V6=y,则屏蔽掉</span><br><span class="hljs-attribute">CONFIG_ARCH_MULTI_V7</span>=y<br><span class="hljs-attribute">CONFIG_ARCH_MULTI_V6_V7</span>=y<br></code></pre></td></tr></table></figure><h3 id="4-设备树文件选择"><a href="#4-设备树文件选择" class="headerlink" title="4.设备树文件选择"></a>4.设备树文件选择</h3><p>（1）为了先完成开发板的启动，先使用nxp提供的dtb文件 imx6ull-14x14-evk.dtb，文件位置在arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;nxp&#x2F;imx&#x2F;下，我们把imx6ull-14x14-evk.dtb拷贝一份，命名为imx6ull-hailin.dtb(随意)</p><p>（2）修改设备树目录下的Makefile文件</p><p>此时我们复制完后，make时并不会来编译我们的dtb文件，我们需要在Makefile文件里把我们的dtb添加上</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">326 </span>        imx6ul-tx6ul-<span class="hljs-number">0011</span>.dtb \<br><span class="hljs-symbol">327 </span>        imx6ul-tx6ul-mainboard.dtb \<br><span class="hljs-symbol">328 </span>        imx6ull-<span class="hljs-number">14</span>x14-evk.dtb \       -&gt;放在之后即可<br><span class="hljs-symbol">329 </span>        imx6ull-hailin.dtb \          -&gt;拷贝的dtb<br><span class="hljs-symbol">330 </span>        imx6ull-colibri-aster.dtb \<br></code></pre></td></tr></table></figure><p>然后回到内核根目录下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf- all -j16<br></code></pre></td></tr></table></figure><p>(3)编译成功后将zimage和imx6ull-14x14-evk.dtb文件拷贝到 开发板  &#x2F;run&#x2F;media&#x2F;mmcblk1p1&#x2F; 下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift">scp <span class="hljs-operator">-</span>r arch<span class="hljs-regexp">/arm/</span>boot<span class="hljs-regexp">/zImage root@开发板ip:/</span>run<span class="hljs-regexp">/media/</span>mmcblk1p1<br>scp <span class="hljs-operator">-</span>r arch<span class="hljs-regexp">/arm/</span>boot<span class="hljs-regexp">/dts/</span>nxp<span class="hljs-regexp">/imx/</span>imx6ull<span class="hljs-operator">-</span>14x14<span class="hljs-operator">-</span>evk.dtb root<span class="hljs-meta">@开发板ip</span>:<span class="hljs-regexp">/run/</span>media<span class="hljs-operator">/</span>mmcblk1p1<br></code></pre></td></tr></table></figure><p>然后复位开发板。</p><p>从dmesg打印信息可以看到已经成功启动了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Starting</span> kernel ...<br><br><span class="hljs-attribute">Booting</span> Linux <span class="hljs-literal">on</span> physical CPU <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">Linux</span> version <span class="hljs-number">6</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span>-rc5-dirty (root@ubuntu) (arm-linux-gnueabihf-gcc (Ubuntu <span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>ubuntu1~<span class="hljs-number">20</span>.<span class="hljs-number">04</span>.<span class="hljs-number">2</span>) <span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>, GNU ld (GNU Binutils for Ubuntu) <span class="hljs-number">2</span>.<span class="hljs-number">34</span>) #<span class="hljs-number">1</span> SMP PREEMPT Sun Apr <span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">55</span> CST <span class="hljs-number">2025</span><br><br></code></pre></td></tr></table></figure><h3 id="5-u-boot修改"><a href="#5-u-boot修改" class="headerlink" title="5.u-boot修改"></a>5.u-boot修改</h3><p>在启动过程中应该会看到内核找不到根文件系统</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Kernel panic - <span class="hljs-keyword">not</span> syncing: VFS: Unable <span class="hljs-keyword">to</span> mount root fs <span class="hljs-keyword">on</span> unknown-<span class="hljs-keyword">block</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>---[ <span class="hljs-keyword">end</span> Kernel panic - <span class="hljs-keyword">not</span> syncing: VFS: Unable <span class="hljs-keyword">to</span> mount root fs <span class="hljs-keyword">on</span> unknown-<span class="hljs-keyword">block</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) ]---<br></code></pre></td></tr></table></figure><p>原因是我们没有在bootargs里指定文件系统的位置，内核不知道去哪里挂载</p><p>（1）进入uboot命令行,我是从 eMMC 分区启动，通常加参数像这样</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">setenv bootargs &#x27;console=ttymxc0,<span class="hljs-number">115200</span> root=/dev/mmcblk1p2 rootwait rw&#x27;<br>saveenv<br></code></pre></td></tr></table></figure><p>参数的具体含义可以参考之前文章</p><p>[]: <a href="https://github.com/HL0019/Uboot-Learning-Record/blob/main/uboot-problem-analysis.md">https://github.com/HL0019/Uboot-Learning-Record/blob/main/uboot-problem-analysis.md</a></p><p>然后kernel就可以正常启动了。</p><p>（2）启动方式</p><p>因为现在跑的是nxp提供的dtb文件，和我们开发板上的网口可能不一样，为了可以次可以正常启动，我这里把zimage和dtb的启动方式改为了tftp，让它使用uboot的tftp来加载kernrl和dtb。</p><p>我们还是进入uboot命令行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> ipaddr <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.xxx(开发板的ip)<br><span class="hljs-attribute">setenv</span> serverip <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.xxx(主机ip)<br><br><span class="hljs-attribute">setenv</span> kernel_addr <span class="hljs-number">0</span>x80800000<br><span class="hljs-attribute">setenv</span> fdt_addr <span class="hljs-number">0</span>x83000000<br><br><span class="hljs-attribute">setenv</span> ethaddr <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">33</span>:<span class="hljs-number">44</span>:<span class="hljs-number">55</span>   # 若未设置过 ethaddr，请添加<br><br><span class="hljs-attribute">tftp</span> <span class="hljs-variable">$&#123;kernel_addr&#125;</span> zImage<br><span class="hljs-attribute">tftp</span> <span class="hljs-variable">$&#123;fdt_addr&#125;</span> imx6ull-hailin.dtb<br><br><span class="hljs-attribute">bootz</span> <span class="hljs-variable">$&#123;kernel_addr&#125;</span> - <span class="hljs-variable">$&#123;fdt_addr&#125;</span><br><br></code></pre></td></tr></table></figure><p>你可以把这些命令合并成 <code>bootcmd</code> 并保存,这样每次上电开发板就会自动执行，省得每次敲一遍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootcmd &#x27;setenv ipaddr <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.xxx.xxx; setenv serverip <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.xxx.xxx; setenv kernel_addr <span class="hljs-number">0</span>x80800000; setenv fdt_addr <span class="hljs-number">0</span>x83000000; setenv ethaddr <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">33</span>:<span class="hljs-number">44</span>:<span class="hljs-number">55</span>; tftp <span class="hljs-variable">$&#123;kernel_addr&#125;</span> zImage; tftp <span class="hljs-variable">$&#123;fdt_addr&#125;</span> imx6ull-.dtb; bootz <span class="hljs-variable">$&#123;kernel_addr&#125;</span> - <span class="hljs-variable">$&#123;fdt_addr&#125;</span>&#x27;<br><span class="hljs-attribute">saveenv</span><br></code></pre></td></tr></table></figure><p>这样我们下次在主机修改完设备树直接把dtb文件放到主机的tftp服务器目录下（我的是&#x2F;tftp），板子上电后就可以直接从这个目录下来加载文件了。</p><p>####接下来就是漫长的适配环节了####</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>全志A33启动方式</title>
    <link href="/2025/05/11/%E5%85%A8%E5%BF%97A33%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/05/11/%E5%85%A8%E5%BF%97A33%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>全志A33芯片支持NAND&#x2F;Nor Flash，SD card，USB四种启动方式</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3dc6d21ba22900fac2ca00b90d0407f1.png#pic_center" alt="img"></p><ol><li><h2 id="NAND-Flash-启动"><a href="#NAND-Flash-启动" class="headerlink" title="NAND Flash 启动"></a><strong>NAND Flash 启动</strong></h2></li></ol><ul><li><strong>原理</strong>：芯片上电后，内部 BootROM（固化在芯片中的最小启动程序）会尝试访问 NAND Flash，从中读取 Boot0（一级启动程序）加载到内部 SRAM 并执行。</li><li><strong>Boot0 的作用</strong>：初始化 DRAM，并加载 Boot1（如 U-Boot）到 DRAM。</li><li><strong>缺点</strong>：NAND Flash 不可随机读取，需要 ECC 和 FTL 管理，启动过程较复杂。</li></ul><p>那么什么是 ECC 和 FTL 呢？</p><p>首先是ECC</p><ul><li>ECC（Error Correction Code）纠错码，用于检测和纠正 NAND Flash 存储过程中出现的位错误（bit error）</li></ul><p>  因为NAND Flash 可靠性相对较低，经过多次擦写后，容易出现位翻转（bit-flip）。</p><p>  特别是 MLC、TLC 类型的 NAND Flash，出错概率更高。</p><ul><li><p>工作原理：写入数据时，会同时写入一个 ECC 校验，读取数据时，用 ECC 校验是否有错误并进行纠正。</p></li><li><p>常见的ECC类型：</p><p>BCH RS LDPC</p></li><li><p>ECC 通常存储在 <strong>OOB 区（Out-Of-Band 区）</strong>，即 NAND Flash 的<strong>每一页</strong>数据旁边的一小块区域。</p></li></ul><p>FTL </p><ul><li>屏蔽 NAND Flash 的物理擦写机制和坏块管理，为上层提供像块设备一样的访问方式（比如像磁盘一样顺序读写）。</li><li>Linux 中由 MTD + UBI + UBIFS 提供支持。</li></ul><h2 id="2-NOR-Flash-启动"><a href="#2-NOR-Flash-启动" class="headerlink" title="2.NOR Flash 启动"></a>2.NOR Flash 启动</h2><ul><li><strong>原理</strong>：芯片从 NOR Flash 直接取指令执行（XIP：eXecute In Place），即 BootROM 直接从 NOR 读取并执行 Boot0。</li><li><strong>优点</strong>：访问简单，启动快，适合做安全引导。</li><li><strong>缺点</strong>：容量小。</li></ul><h2 id="3-SD-卡启动"><a href="#3-SD-卡启动" class="headerlink" title="3.SD 卡启动"></a>3.SD 卡启动</h2><p>这个就是一种非常常见的启动方式了</p><ul><li><strong>原理</strong>：芯片上电后尝试从 SD 卡（或 eMMC）中读取 Boot0，如果存在合法的启动分区（如全志的 FES 格式或 FAT&#x2F;EXT 文件系统中的 boot 文件），则加载执行。</li><li><strong>优点</strong>：开发调试方便，可热插拔。不依赖板载存储，易于更新系统。</li><li><strong>缺点</strong>：插拔稳定性差，不适合量产产品长期运行。</li></ul><h2 id="4-USB-启动（FEL-模式）"><a href="#4-USB-启动（FEL-模式）" class="headerlink" title="4.USB 启动（FEL 模式）"></a>4.USB 启动（FEL 模式）</h2><ul><li><p><strong>原理</strong>：如果前几种介质都未能启动成功，或者按下某个启动键进入“USB启动&#x2F;FEL模式”，芯片进入 USB FEL 模式，等待通过 USB 口接入主机（如 PC）下载并运行启动程序。</p></li><li><p><strong>FEL</strong> 是全志芯片特有的一种 USB 下载协议（类似串口烧录）。</p></li><li><p><strong>优点</strong>：无需板载存储即可烧录&#x2F;启动系统。</p></li><li><p><strong>缺点</strong>：启动速度慢，依赖外部工具。</p></li></ul><h3 id="解释一下什么是FEL模式"><a href="#解释一下什么是FEL模式" class="headerlink" title="解释一下什么是FEL模式"></a>解释一下什么是FEL模式</h3><p><strong>FEL（Firmware Easy Loader）模式</strong> 是全志芯片的 <strong>USB 下载启动模式</strong>，当没有有效的启动介质时（或者人为触发）进入。</p><p>全志芯片上电后，从 BootROM 尝试启动 NAND、eMMC、SD 等存储介质，如果没有发现有效的 Boot0，会自动进入 FEL 模式（或通过按键强制进入），芯片在 USB 接口上枚举为一个特殊设备（全志的 USB Vendor ID 和 Product ID）主机（通常是电脑）通过 <code>sunxi-fel</code> 工具向芯片 RAM 下载并执行程序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异常向量表</title>
    <link href="/2025/05/11/%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8/"/>
    <url>/2025/05/11/%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在开始学习Interrupt子系统之前，需要了解的一些知识</p><h3 id="1-异常向量表"><a href="#1-异常向量表" class="headerlink" title="1.异常向量表"></a>1.异常向量表</h3><p>向量表&#x2F;页的工作方式是 CPU 将程序计数器和处理器状态存储在内部寄存器中，并将程序计数器放在相应的向量地址。向量表可以放在内存中的两个位置：地址 0x00000000 或地址 0xFFFF0000。该位置通过 CP15 控制寄存器 1 中的单个位来选择。Linux 支持将向量放在任一位置，但优先选择 0xFFFF0000。如果 MMU 关闭并且您与从地址 0x00000000 开始的物理内存有 1:1 映射，则使用地址 0x00000000 通常最有帮助。如果 MMU 处于打开状态（对我们来说是打开的），则使用的地址是虚拟地址，即使向量表也要经过 MMU 转换，并且通常使用内存中高位（地址 0xFFFF0000）的向量。</p><p>先看一下异常向量的构造</p><p>arch&#x2F;arm&#x2F;kernrl&#x2F;entry-armv.S</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.vectors</span><span class="hljs-selector-class">.bhb</span><span class="hljs-selector-class">.bpiall</span>, &quot;ax&quot;, %progbits<br>RELOC_TEXT_NONE<br><span class="hljs-built_in">W</span>(b)vector_rst<br><span class="hljs-built_in">W</span>(b)vector_bhb_bpiall_und<br><span class="hljs-built_in">ARM</span>(.reloc., R_ARM_LDR_PC_G0, .L__vector_bhb_bpiall_swi)<br><span class="hljs-built_in">THUMB</span>(.reloc., R_ARM_THM_PC12, .L__vector_bhb_bpiall_swi)<br><span class="hljs-built_in">W</span>(ldr)pc, .<br><span class="hljs-built_in">W</span>(b)vector_bhb_bpiall_pabt<br><span class="hljs-built_in">W</span>(b)vector_bhb_bpiall_dabt<br><span class="hljs-built_in">W</span>(b)vector_addrexcptn<br><span class="hljs-built_in">W</span>(b)vector_bhb_bpiall_irq<br><span class="hljs-built_in">W</span>(b)vector_bhb_bpiall_fiq<br></code></pre></td></tr></table></figure><p>在运行的时并不能保证这段代码的地址就是0xFFFF0000，所以就需要把这段代码所在的虚拟地址设置为0xFFFF0000，然后中断发生时，执行跳转指令 W(b) vector_bhb_bpiall_irq。</p><p>并且所处的段是 .vectors，下面还会提及。</p><p>arch&#x2F;arm&#x2F;kernrl&#x2F;head.S   这是arm架构运行的第一个文件</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tcl">/*<br> * The following calls CPU specific code in a position independent<br> * manner.  See arch/arm/mm/<span class="hljs-keyword">proc</span>-*.S<span class="hljs-title"> for</span> details.<span class="hljs-title">  r10</span> =<span class="hljs-title"> base</span> of<br> *<span class="hljs-title"> xxx_proc_info</span> structure<span class="hljs-title"> selected</span> by<span class="hljs-title"> __lookup_processor_type</span><br> *<span class="hljs-title"> above.</span><br> *<br> *<span class="hljs-title"> The</span> processor<span class="hljs-title"> init</span> function<span class="hljs-title"> will</span> be<span class="hljs-title"> called</span> with:<br> *<span class="hljs-title">  r1</span> -<span class="hljs-title"> machine</span> type<br> *<span class="hljs-title">  r2</span> -<span class="hljs-title"> boot</span> data (atags/dt)<span class="hljs-title"> pointer</span><br> *<span class="hljs-title">  r4</span> -<span class="hljs-title"> translation</span> table<span class="hljs-title"> base</span> (low<span class="hljs-title"> word)</span><br> *<span class="hljs-title">  r5</span> -<span class="hljs-title"> translation</span> table<span class="hljs-title"> base</span> (high<span class="hljs-title"> word,</span> if<span class="hljs-title"> LPAE)</span><br> *<span class="hljs-title">  r8</span> -<span class="hljs-title"> translation</span> table<span class="hljs-title"> base</span> 1 (pfn<span class="hljs-title"> if</span> LPAE)<br> *<span class="hljs-title">  r9</span> -<span class="hljs-title"> cpuid</span><br> *<span class="hljs-title">  r13</span> -<span class="hljs-title"> virtual</span> address<span class="hljs-title"> for</span> __enable_mmu -&gt;<span class="hljs-title"> __turn_mmu_on</span><br> *<br> *<span class="hljs-title"> On</span> return,<span class="hljs-title"> the</span> CPU<span class="hljs-title"> will</span> be<span class="hljs-title"> ready</span> for<span class="hljs-title"> the</span> MMU<span class="hljs-title"> to</span> be<span class="hljs-title"> turned</span> on,<br> *<span class="hljs-title"> r0</span> will<span class="hljs-title"> hold</span> the<span class="hljs-title"> CPU</span> control<span class="hljs-title"> register</span> value,<span class="hljs-title"> r1,</span> r2,<span class="hljs-title"> r4,</span> and<br> *<span class="hljs-title"> r9</span> will<span class="hljs-title"> be</span> preserved.<span class="hljs-title">  r5</span> will<span class="hljs-title"> also</span> be<span class="hljs-title"> preserved</span> if<span class="hljs-title"> LPAE.</span><br> */<span class="hljs-title"></span><br><span class="hljs-title">ldr</span>r13, =__mmap_switched@<span class="hljs-title"> address</span> to<span class="hljs-title"> jump</span> to<span class="hljs-title"> after</span><br>@<span class="hljs-title"> mmu</span> has<span class="hljs-title"> been</span> enabled<span class="hljs-title"></span><br><span class="hljs-title">badr</span>lr, 1f@<span class="hljs-title"> return</span> (PIC)<span class="hljs-title"> address</span><br>#ifdef<span class="hljs-title"> CONFIG_ARM_LPAE</span><br><span class="hljs-title">mov</span>r5, #0@<span class="hljs-title"> high</span> TTBR0<span class="hljs-title"></span><br><span class="hljs-title">mov</span>r8,<span class="hljs-title"> r4,</span> lsr #12@<span class="hljs-title"> TTBR1</span> is<span class="hljs-title"> swapper_pg_dir</span> pfn<br>#else<span class="hljs-title"></span><br><span class="hljs-title">mov</span>r8,<span class="hljs-title"> r4</span>@<span class="hljs-title"> set</span> TTBR1<span class="hljs-title"> to</span> swapper_pg_dir<br>#endif<span class="hljs-title"></span><br><span class="hljs-title">ldr</span>r12, [r10, #PROCINFO_INITFUNC]<span class="hljs-title"></span><br><span class="hljs-title">add</span>r12,<span class="hljs-title"> r12,</span> r10<span class="hljs-title"></span><br><span class="hljs-title">ret</span>r12<br>1:<span class="hljs-title">b</span>__enable_mmu<span class="hljs-title"></span><br><span class="hljs-title">ENDPROC(stext)</span><br>.ltorg<br></code></pre></td></tr></table></figure><p>首先将 __mmap_switched 的地址放到 r13寄存器</p><p>然后跳转__enable_mmu去开启MMU</p><p>在启动MMU后回跳转执行到 __mmap_switched</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__INIT</span><br><span class="hljs-variable">__mmap_switched</span>:<br><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br>blkasan_early_init<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>movlr, #<span class="hljs-number">0</span><br>bstart_kernel<br>ENDPROC(<span class="hljs-variable">__mmap_switched</span>)<br>...<br></code></pre></td></tr></table></figure><p>通过汇编跳转到了 start_kernel()    init\main.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">start_kernel</span>() <br><span class="hljs-built_in">setup_arch</span>()<br><span class="hljs-built_in">paging_init</span>()<br><span class="hljs-built_in">devicemaps_init</span>()<br></code></pre></td></tr></table></figure><p>我们进入这个函数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title">devicemaps_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> machine_desc *mdesc)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Allocate the vector page early.</span><br><span class="hljs-comment"> */</span><br>vectors = <span class="hljs-built_in">early_alloc</span>(PAGE_SIZE * <span class="hljs-number">2</span>);<br><span class="hljs-built_in">early_trap_init</span>(vectors);<br>...<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create a mapping for the machine vectors at the high-vectors</span><br><span class="hljs-comment"> * location (0xffff0000).  If we aren&#x27;t using high-vectors, also</span><br><span class="hljs-comment"> * create a mapping at the low-vectors virtual address.</span><br><span class="hljs-comment"> */</span><br>map.pfn = __phys_to_pfn(<span class="hljs-built_in">virt_to_phys</span>(vectors));<br>map.<span class="hljs-keyword">virtual</span> = <span class="hljs-number">0xffff0000</span>;<br>map.length = PAGE_SIZE;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KUSER_HELPERS</span><br>map.type = MT_HIGH_VECTORS;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>map.type = MT_LOW_VECTORS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>early_alloc(PAGE_SIZE * 2); 申请8k的内存</li><li>early_trap_init(vectors);         把异常向量表复制到这8k的位置</li></ul><p>其余部分就是映射，将0xffff0000 ——&gt; vectors</p><h3 id="2-向量表的映射"><a href="#2-向量表的映射" class="headerlink" title="2.向量表的映射"></a>2.向量表的映射</h3><p>进入early_trap_init()</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sqf">void <span class="hljs-variable">__init</span> early_trap_init(void *vectors_base)<br>&#123;<br>extern char <span class="hljs-variable">__stubs_start</span>[], <span class="hljs-variable">__stubs_end</span>[];<br>extern char <span class="hljs-variable">__vectors_start</span>[], <span class="hljs-variable">__vectors_end</span>[];<br>unsigned i;<br><br>vectors_page = vectors_base;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Poison the vectors page with an undefined instruction.  This</span><br><span class="hljs-comment"> * instruction is chosen to be undefined for both ARM and Thumb</span><br><span class="hljs-comment"> * ISAs.  The Thumb version is an undefined instruction with a</span><br><span class="hljs-comment"> * branch back to the undefined instruction.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; PAGE_SIZE / <span class="hljs-built_in">sizeof</span>(u32); i++)<br>((u32 *)vectors_base)[i] = <span class="hljs-number">0</span>xe7fddef1;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copy the vectors, stubs and kuser helpers (in entry-armv.S)</span><br><span class="hljs-comment"> * into the vector page, mapped at 0xffff0000, and ensure these</span><br><span class="hljs-comment"> * are visible to the instruction stream.</span><br><span class="hljs-comment"> */</span><br>copy_from_lma(vectors_base, <span class="hljs-variable">__vectors_start</span>, <span class="hljs-variable">__vectors_end</span>);<br>copy_from_lma(vectors_base + <span class="hljs-number">0</span>x1000, <span class="hljs-variable">__stubs_start</span>, <span class="hljs-variable">__stubs_end</span>);<br><br>kuser_init(vectors_base);<br><br>flush_vectors(vectors_base, <span class="hljs-number">0</span>, PAGE_SIZE * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到将 __vectors_start copy到了这块物理地址上</p><p>那么 __vectors_start 是什么呢？这就要去内核查看链接脚本了</p><p>arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">__vectors_start</span> = LOADADDR(.vectors)<span class="hljs-comment">; __vectors_end = LOADADDR(.vectors) + SIZEOF(.vectors); </span><br></code></pre></td></tr></table></figure><p>__vectors_start &#x3D; LOADADDR(.vectors) 会获取这个段的地址，那么向量表刚好就在.vectors。到此就完成了向量表的复制。</p><h3 id="3-调用过程"><a href="#3-调用过程" class="headerlink" title="3.调用过程"></a>3.调用过程</h3><p>回到向量表，当发生异常时，会来调用 vector_bhb_bpiall_irq</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupt dispatcher</span><br><span class="hljs-comment"> */</span><br>vector_stubirq, IRQ_MODE, <span class="hljs-number">4</span><br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>而 vector_stub 是一个宏，展开为：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">.macro</span>vector_stub, name, mode, correction=<span class="hljs-number">0</span><br>.align<span class="hljs-number">5</span><br>...<br>vector_\name:<br>.if \correction<br><span class="hljs-keyword">sub</span>lr, lr, <span class="hljs-meta">#\correction</span><br>.endif<br><br>@ Save <span class="hljs-built_in">r0</span>, lr_&lt;exception&gt; (parent PC)<br>stmiasp, &#123;<span class="hljs-built_in">r0</span>, lr&#125;@ save <span class="hljs-built_in">r0</span>, lr<br><br>@ Save spsr_&lt;exception&gt; (parent CPSR)<br>.Lvec_\name:<br>mrslr, <span class="hljs-built_in">spsr</span>@从<span class="hljs-built_in">SPSR</span>寄存器(当前程序状态寄存器)中获取打断的程序位于什么模式下<br>strlr, [sp, <span class="hljs-meta">#8]@ save spsr</span><br><br>@<br>@ Prepare for SVC32 mode.  IRQs remain disabled.<br>@<br>mrs<span class="hljs-built_in">r0</span>, cpsr<br><span class="hljs-keyword">eor</span><span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-meta">#(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br>msrspsr_cxsf, <span class="hljs-built_in">r0</span><br><br>@<br>@ the branch table must immediately follow this code<br>@<br><span class="hljs-keyword">and</span>lr, lr, <span class="hljs-meta">#0x0f@提取模式</span><br> THUMB(adr<span class="hljs-built_in">r0</span>, <span class="hljs-number">1</span>f)<br> THUMB(ldrlr, [<span class="hljs-built_in">r0</span>, lr, <span class="hljs-keyword">lsl</span> <span class="hljs-meta">#2])</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">r0</span>, sp<br> ARM(ldrlr, [pc, lr, <span class="hljs-keyword">lsl</span> <span class="hljs-meta">#2])</span><br>movspc, lr @执行<br>ENDPROC(vector_\name)<br></code></pre></td></tr></table></figure><p>根据提取出来的模式来执行以下的函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupt dispatcher</span><br><span class="hljs-comment"> */</span><br>vector_stubirq, IRQ_MODE, <span class="hljs-number">4</span><br><span class="hljs-selector-class">.long</span>__irq_usr@  <span class="hljs-number">0</span>  (USR_26 / USR_32)<br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">1</span>  (FIQ_26 / FIQ_32)<br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">2</span>  (IRQ_26 / IRQ_32)<br><span class="hljs-selector-class">.long</span>__irq_svc@  <span class="hljs-number">3</span>  (SVC_26 / SVC_32)<br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">4</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">5</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">6</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">7</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">8</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-number">9</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  <span class="hljs-selector-tag">b</span><br><span class="hljs-selector-class">.long</span>__irq_invalid@  c<br><span class="hljs-selector-class">.long</span>__irq_invalid@  d<br><span class="hljs-selector-class">.long</span>__irq_invalid@  e<br><span class="hljs-selector-class">.long</span>__irq_invalid@  f<br></code></pre></td></tr></table></figure><p>在用户态发生执行 __irq_usr</p><p>在内核态发生执行 __irq_svc，（在linux中，禁止在其他模式下产生中断）</p><p>最后来看一下这两个函数</p><p>arch&#x2F;arm&#x2F;kernrl&#x2F;entry-armv.S</p><p>__irq_usr：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">__irq_usr:<br>usr_entry@保存现场<br>kuser_cmpxchg_check<br>irq_handler from_user=<span class="hljs-number">1</span>   @处理<br>get_thread_info tsk<br>movwhy, #<span class="hljs-number">0</span><br><span class="hljs-selector-tag">b</span>ret_to_user_from_irq  @恢复现场<br> <span class="hljs-built_in">UNWIND</span>(<span class="hljs-selector-class">.fnend</span>)<br><span class="hljs-function"><span class="hljs-title">ENDPROC</span><span class="hljs-params">(__irq_usr)</span></span><br></code></pre></td></tr></table></figure><p>__irq_svc：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">__irq_svc:</span><br>svc_entry@保存现场<br>irq_handler from_user=<span class="hljs-number">0</span>  @处理<br><br><span class="hljs-meta">#ifdef CONFIG_PREEMPTION</span><br>ldr<span class="hljs-built_in">r8</span>, [tsk, <span class="hljs-meta">#TI_PREEMPT]@ get preempt count</span><br>ldr<span class="hljs-built_in">r0</span>, [tsk, <span class="hljs-meta">#TI_FLAGS]@ get flags</span><br>teq<span class="hljs-built_in">r8</span>, <span class="hljs-meta">#0   @ if preempt count != 0</span><br>movne<span class="hljs-built_in">r0</span>, <span class="hljs-meta">#0   @ force flags to 0</span><br><span class="hljs-keyword">tst</span><span class="hljs-built_in">r0</span>, <span class="hljs-meta">#_TIF_NEED_RESCHED</span><br>blnesvc_preempt<br><span class="hljs-meta">#endif</span><br>svc_exit <span class="hljs-built_in">r5</span>, irq = <span class="hljs-number">1</span>@恢复现场<br> UNWIND(.fnend)<br>ENDPROC(__irq_svc)<br></code></pre></td></tr></table></figure><p>处理的流程都是一样的，而这里有个处理函数 irq_handler，它是由 GIC Driver 提供的。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-meta">.macro</span>irq_handler, from_user:req<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">r1</span>, <span class="hljs-built_in">sp</span><br>ldr_this_cpu <span class="hljs-built_in">r2</span>, irq_stack_ptr, <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r3</span><br><span class="hljs-meta">.if</span>\from_user == <span class="hljs-number">0</span><br><span class="hljs-comment">@</span><br><span class="hljs-comment">@ If we took the interrupt while running in the kernel, we may already</span><br><span class="hljs-comment">@ be using the IRQ stack, so revert to the original value in that case.</span><br><span class="hljs-comment">@</span><br><span class="hljs-keyword">subs</span><span class="hljs-built_in">r3</span>, <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r1</span><span class="hljs-comment">@ SP above bottom of IRQ stack?</span><br>rsbscs<span class="hljs-built_in">r3</span>, <span class="hljs-built_in">r3</span>, <span class="hljs-symbol">#THREAD_SIZE</span><span class="hljs-comment">@ ... and below the top?</span><br><span class="hljs-comment">#ifdef CONFIG_VMAP_STACK</span><br>ldr_va<span class="hljs-built_in">r3</span>, high_memory, cc<span class="hljs-comment">@ End of the linear region</span><br><span class="hljs-keyword">cmpcc</span><span class="hljs-built_in">r3</span>, <span class="hljs-built_in">r1</span><span class="hljs-comment">@ Stack pointer was below it?</span><br><span class="hljs-comment">#endif</span><br><span class="hljs-keyword">bcc</span><span class="hljs-number">0</span>f<span class="hljs-comment">@ If not, switch to the IRQ stack</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span><br><span class="hljs-keyword">bl</span>generic_handle_arch_irq      &lt;----------------调用的函数<br><span class="hljs-keyword">b</span><span class="hljs-number">1</span>f<br></code></pre></td></tr></table></figure><p>generic_handle_arch_irq 以后再做分析。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于MainLine Kernel Pinctrl子系统分析</title>
    <link href="/2025/05/05/Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/05/05/Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本数据结构"><a href="#一、基本数据结构" class="headerlink" title="一、基本数据结构"></a>一、基本数据结构</h2><h3 id="1-pinctroller"><a href="#1-pinctroller" class="headerlink" title="1. pinctroller"></a>1. pinctroller</h3><p>pinctrl_dev 与 pinctrl_desc</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs clean">struct pinctrl_dev &#123;<br>struct list_head node;<br>struct pinctrl_desc *desc;<br>struct radix_tree_root pin_desc_tree;<br>#ifdef CONFIG_GENERIC_PINCTRL_GROUPS<br>struct radix_tree_root pin_group_tree;<br>unsigned int num_groups;<br>#endif<br>#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS<br>struct radix_tree_root pin_function_tree;<br>unsigned int num_functions;<br>#endif<br>struct list_head gpio_ranges;<br>struct device *dev;<br>struct <span class="hljs-keyword">module</span> *owner;<br>void *driver_data;<br>struct pinctrl *p;<br>struct pinctrl_state *hog_default;<br>struct pinctrl_state *hog_sleep;<br>struct mutex mutex;<br>#ifdef CONFIG_DEBUG_FS<br>struct dentry *device_root;<br>#endif<br>&#125;<br><br>##########################################<br>##########################################<br><br>struct pinctrl_desc &#123;<br>const char *name;<br>const struct pinctrl_pin_desc *pins;<br>unsigned int npins;<br>const struct pinctrl_ops *pctlops;<br>const struct pinmux_ops *pmxops;<br>const struct pinconf_ops *confops;<br>struct <span class="hljs-keyword">module</span> *owner;<br>#ifdef CONFIG_GENERIC_PINCONF<br>unsigned int num_custom_params;<br>const struct pinconf_generic_params *custom_params;<br>const struct pin_config_item *custom_conf_items;<br>#endif<br>bool link_consumers;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们进入到驱动目录里 drivers\pinctrl\freescale\pinctrl-imx.c 的 .probe函数</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">int imx_pinctrl_probe(struct platform_device *pdev,<br>      const struct imx_pinctrl_soc_info *info)<br>&#123;<br>struct regmap_config config = &#123; .<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;gpr&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *dev_np = pdev-&gt;</span>dev.of_node;<br>struct pinctrl_desc *imx_pinctrl_desc;<br>struct device_node *np;<br>struct imx_pinctrl *ipctl;<br>struct regmap *gpr;<br>int ret, i;<br>...<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span> = info-&gt;</span>pins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">npins</span> = info-&gt;</span>npins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pctlops = &amp;imx_pctrl_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pmxops = &amp;imx_pmx_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>confops = &amp;imx_pinconf_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>owner = THIS_MODULE;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中比较重要的，struct pctlops 、struct pmxops，pinconf_ops,我们看看他们的结构体时怎么构造的</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs clean">struct pinctrl_ops &#123;<br>int (*get_groups_count) (struct pinctrl_dev *pctldev);<br>const char *(*get_group_name) (struct pinctrl_dev *pctldev,<br>       unsigned int selector);<br>int (*get_group_pins) (struct pinctrl_dev *pctldev,<br>       unsigned int selector,<br>       const unsigned int **pins,<br>       unsigned int *num_pins);<br>void (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s,<br>      unsigned int offset);<br>int (*dt_node_to_map) (struct pinctrl_dev *pctldev,<br>       struct device_node *np_config,<br>       struct pinctrl_map **map, unsigned int *num_maps);<br>void (*dt_free_map) (struct pinctrl_dev *pctldev,<br>     struct pinctrl_map *map, unsigned int num_maps);<br>&#125;;<br><br>##################################<br><br>struct pinmux_ops &#123;<br>int (*request) (struct pinctrl_dev *pctldev, unsigned int offset);<br>int (*free) (struct pinctrl_dev *pctldev, unsigned int offset);<br>int (*get_functions_count) (struct pinctrl_dev *pctldev);<br>const char *(*get_function_name) (struct pinctrl_dev *pctldev,<br>  unsigned int selector);<br>int (*get_function_groups) (struct pinctrl_dev *pctldev,<br>    unsigned int selector,<br>    const char * const **groups,<br>    unsigned int *num_groups);<br>int (*set_mux) (struct pinctrl_dev *pctldev, unsigned int func_selector,<br>unsigned int group_selector);<br>int (*gpio_request_enable) (struct pinctrl_dev *pctldev,<br>    struct pinctrl_gpio_range *range,<br>    unsigned int offset);<br>.....<br>&#125;;<br><br>#############################################<br>struct pinconf_ops &#123;<br>#ifdef CONFIG_GENERIC_PINCONF<br>bool is_generic;<br>#endif<br>int (*pin_config_get) (struct pinctrl_dev *pctldev,<br>       unsigned int pin,<br>       unsigned long *config);<br>int (*pin_config_set) (struct pinctrl_dev *pctldev,<br>       unsigned int pin,<br>       unsigned long *configs,<br>       unsigned int num_configs);<br>int (*pin_config_group_get) (struct pinctrl_dev *pctldev,<br>     unsigned int selector,<br>     unsigned long *config);<br>int (*pin_config_group_set) (struct pinctrl_dev *pctldev,<br>     unsigned int selector,<br>     unsigned long *configs,<br>     unsigned int num_configs);<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先来解释为什么要有 pinctrl_ops 这么一个结构体呢？我们可以看到 struct pinctrl_desc 里有这么两个属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> *pins;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">void</span> *drv_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这两个属性都是用来描述单个引脚的，而看 pinctrl_ops 提供的函数，可以获得多个group里的pin信息（提供 groups、pins、group和pin之间的组织关系）。</p><p>然后再来看 pinmux_ops 结构体，比较重要的函数就是他就是set_mux(),来把  pinctrl_ops 获取 的 描述信息去设置mux寄存器(复用为什么功能，GPIO、UART、SPI之类)。</p><p>可以理解为：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">驱动请求(pinctrl_select_state)<br>    ↓<br>根据设备树找 pinctrl <span class="hljs-keyword">state</span><br>    ↓<br>根据 pctlops 描述，找到对应的 <span class="hljs-keyword">group</span>(s)<br>    ↓<br>调用 pmxops-&gt;set_mux，把 pins 设置到正确的功能<br></code></pre></td></tr></table></figure><p>最后就是 pinconf_ops ，它的作用是配置 pin 的电气属性（上拉、下拉、驱动强度等）。</p><p>以上就是pinctroller端的基本数据结构.</p><h3 id="2-注册函数"><a href="#2-注册函数" class="headerlink" title="2.注册函数"></a>2.注册函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *<span class="hljs-built_in">pinctrl_register</span>(<span class="hljs-keyword">struct</span> pinctrl_desc *pctldesc,<br>    <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">void</span> *driver_data);<br></code></pre></td></tr></table></figure><p>可以看到参数是一个 struct pinctrl_desc，而返回值是 struct pinctrl_dev，以后就用 pinctrl_dev 来描述一个 pincontroller。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"> pinctrl_flexcan1: flexcan1grp &#123;<br>         fsl,pins = &lt;<br>                 MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX      <span class="hljs-number">0x1b020</span><br>                 MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX      <span class="hljs-number">0x1b020</span><br>         &gt;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面分析的数据结构都是来描述这个 pincontroller.</p><h3 id="4-pinctrl-client"><a href="#4-pinctrl-client" class="headerlink" title="4.pinctrl  client"></a>4.pinctrl  client</h3><p>但是我们在使用中还有一个client，这部分是怎么描述的？</p><p>先看在dtb中的编写:通过 pinctrl-names 的属性来选择 pin要配置为什么模式。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">device</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span>，<span class="hljs-string">&quot;sleep&quot;</span><span class="hljs-punctuation">;</span><br>        pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_device0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        pinctrl<span class="hljs-number">-1</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_device1</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>首先设备树会被编译成 platform_device结构体（不全是，比如i2c_client）,但是里面都会有一个 device 结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct platform_device &#123;<br>const char*name<span class="hljs-comment">;</span><br>intid<span class="hljs-comment">;</span><br>boolid_auto<span class="hljs-comment">;</span><br>struct devicedev<span class="hljs-comment">;           《--------------</span><br>u64platform_dma_mask<span class="hljs-comment">;</span><br>....<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">i2c_client</span> &#123;<br>...<br><span class="hljs-keyword">struct</span> <span class="hljs-type">i2c_adapter</span> *adapter;<span class="hljs-comment">/* the adapter we sit on*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">device</span> dev;<span class="hljs-comment">/* the device structure*/</span>               《--------------<br>int init_irq;<span class="hljs-comment">/* irq set at initialization*/</span><br>int irq;<span class="hljs-comment">/* irq issued by device*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> detected;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以不管被编译为什么结构体，最终都汇聚到这个 struct device 来和 pinctrl 挂钩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> &#123;<br>...<br><span class="hljs-type">void</span>*platform_data;<span class="hljs-comment">/* Platform specific data, device</span><br><span class="hljs-comment">   core doesn&#x27;t touch it */</span><br><span class="hljs-type">void</span>*driver_data;<span class="hljs-comment">/* Driver data, set and get with</span><br><span class="hljs-comment">   dev_set_drvdata/dev_get_drvdata */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mutex</span>mutex;<span class="hljs-comment">/* mutex to synchronize calls to</span><br><span class="hljs-comment"> * its driver.</span><br><span class="hljs-comment"> */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PINCTRL</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dev_pin_info</span>*pins;            &lt;-------------------------<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dev_msi_info</span>msi;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_HAS_DMA_OPS</span><br>        <span class="hljs-type">const</span> <br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>就是通过  struct dev_pin_info *pins 和 pinctrl 挂钩的。</p><h4 id="4-1struct-dev-pin-info"><a href="#4-1struct-dev-pin-info" class="headerlink" title="4.1struct dev_pin_info"></a>4.1struct dev_pin_info</h4><p>这个结构体只在需要使用pinctrl 子系统时构造。</p><p>可以看出这几个 pinctrl_state 结构体都是由 dtb中的 pinctrl client 的 pinctrl-names 属性构造的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">dev_pin_info</span> &#123;<br><span class="hljs-comment">/* 存放自己添加的状态 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl</span> *p;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *default_state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *init_state;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *sleep_state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *idle_state;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-2自定义状态"><a href="#4-2自定义状态" class="headerlink" title="4.2自定义状态"></a>4.2自定义状态</h4><p>则都是几种常用的状态，那么有没有方法让我们自定义状态呢？</p><p>有的兄弟，有的。</p><p>我们自定义的状态会放在 struct pinctrl *p 里的 struct list_head states 链表里，（关于解析部分之后分析）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">device</span> *dev;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> states;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> *state;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> dt_maps;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">kref</span> users;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-3pinctrl-map-和-pinctrl-setting"><a href="#4-3pinctrl-map-和-pinctrl-setting" class="headerlink" title="4.3pinctrl_map  和 pinctrl_setting"></a>4.3pinctrl_map  和 pinctrl_setting</h4><p>当我们的pinctrl cliend 想要去使用pinctrl，是通过 struct dev_pin_info 去建立联系的，那么我们 pinctroller 的设备节点也得需要去保存到这个结构体里。</p><p>还记得 pctlops 吗，就是它来解析的，它是来处理一组引脚的。这个结构体里有一个函数 dt_node_to_map().</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">int</span> (*dt_node_to_map) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev,<br>               <span class="hljs-keyword">struct</span> device_node *np_config,<br>               <span class="hljs-keyword">struct</span> pinctrl_map **map, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *num_maps);<br></code></pre></td></tr></table></figure><p>就是来把设备树节点转换为一系列的 pinctrl_map 结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map</span> &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *dev_name;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">pinctrl_map_type</span> <span class="hljs-keyword">type</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *ctrl_dev_name;<br><span class="hljs-keyword">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map_mux</span> mux;          <span class="hljs-comment">/* 复用哪些引脚 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map_configs</span> configs;  <span class="hljs-comment">/* 配置哪些引脚 */</span><br>&#125; data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再有 struct pinctrl_map —&gt; struct pinctrl_setting ,去配置这些引脚的功能。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br>enum pinctrl_map_type <span class="hljs-built_in">type</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_dev</span> *pctldev;<br>const char *dev_name;<br><span class="hljs-built_in">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting_mux</span> mux;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_setting_configs</span> configs;<br>&#125; data;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">pinctrl_state</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> node;<br>const char *name;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> settings;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个 struct pinctrl_setting又存放在 pinctrl_state.settings里，以后让这个设备位于某个状态时，就会根据这些 .settings来设置引脚。</p><p>（map —&gt;setting 这部分是内核的工作，想了解可以查看  drivers\pinctrl\core.c）</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">pinctrl_get</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pinctrl</span>()</span><br><span class="hljs-function"><span class="hljs-title">pinctrl_dt_to_map</span>()</span><br><span class="hljs-function"><span class="hljs-title">add_setting</span>()</span><br></code></pre></td></tr></table></figure><h4 id="4-4操作流程"><a href="#4-4操作流程" class="headerlink" title="4.4操作流程"></a>4.4操作流程</h4><p>看一下怎么来根据 .setting 来设置引脚的，进入内核目录 drivers\base\dd.c，查看 really_probe() 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">really_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> test_remove = <span class="hljs-built_in">IS_ENABLED</span>(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;<br>   !drv-&gt;suppress_bind_attrs;<br><span class="hljs-type">int</span> ret, link_ret;<br>...<br><span class="hljs-comment">/* If using pinctrl, bind pins now before probing */</span><br>ret = <span class="hljs-built_in">pinctrl_bind_pins</span>(dev);    &lt;-----------------<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> pinctrl_bind_failed;<br>&#125;<br></code></pre></td></tr></table></figure><p>会看到有一个 pinctrl_bind_pins(),进入查看</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinctrl_bind_pins(struct device *dev)<br>&#123;<br>...<br>    <span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state)) &#123;<br>    <span class="hljs-comment">/* Not supplying this state is perfectly legal */</span><br>    dev_dbg(dev, <span class="hljs-string">&quot;no init pinctrl state\n&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p,<br>                   <span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>default_state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">p</span>, dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>找到一个选择状态函数 pinctrl_select_state(),接着进入</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *<span class="hljs-keyword">state</span>)<br>&#123;<br>if (p-&gt;state == <span class="hljs-keyword">state</span>)<br>return <span class="hljs-number">0</span>;<br><br>return pinctrl_commit_state(p, <span class="hljs-keyword">state</span>);   <span class="hljs-variable">&lt;-------------</span><br><span class="hljs-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>这里会判断一下初始化的状态是否正常，接着进入 pinctrl_commit_state().</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)<br>&#123;<br>struct pinctrl_setting *setting;<br>struct pinctrl_state *old_state = READ_ONCE(p-&gt;state);<br><span class="hljs-keyword">int</span> ret;<br>...<br><span class="hljs-comment">/* Apply all the settings for the new state - pinmux first */</span><br>list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;         &lt;-------------<br><span class="hljs-keyword">switch</span> (setting-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = pinmux_enable_setting(setting);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = <span class="hljs-number">0</span>;   <span class="hljs-comment">//跳过</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>goto unapply_new_state;<br><br><span class="hljs-comment">/* Do not link hogs (circular dependency) */</span><br><span class="hljs-keyword">if</span> (p != setting-&gt;pctldev-&gt;p)<br>pinctrl_link_add(setting-&gt;pctldev, p-&gt;dev);<br>&#125;<br><br><span class="hljs-comment">/* Apply all the settings for the new state - pinconf after */</span><br>list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123; &lt;-------------<br><span class="hljs-keyword">switch</span> (setting-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = <span class="hljs-number">0</span>;   <span class="hljs-comment">// mux 已完成，跳过</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = pinconf_apply_setting(setting);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个switch 语句，这样分布的机制就是为了保证在做 config 设置前，引脚已经正确映射到目标功能（比如 UART1_TX），否则如果 pin 还处于 GPIO 模式，你设置电平、上拉下拉等都没有意义。</p><p>根据 setting-&gt;type 来执行相应的配置函数，对于mux部分执行 pinmux_enable_setting（）,最终调用到了 set_mux 函数来配置引脚的复用。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinmux_enable_setting(const struct pinctrl_setting *setting)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinctrl_ops *pctlops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>pctlops;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinmux_ops *ops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>pmxops;<br>...<br><span class="hljs-function"><span class="hljs-title">ret</span> = ops-&gt;</span><span class="hljs-function"><span class="hljs-title">set_mux</span>(pctldev, setting-&gt;</span><span class="hljs-keyword">data</span>.mux.func,<br>   <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.mux.group);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 config 部分执行 pinconf_apply_setting（），最终调用到了 pin_config_group_set().</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinconf_apply_setting(const struct pinctrl_setting *setting)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;<br><span class="hljs-function"><span class="hljs-title">const</span> struct pinconf_ops *ops = pctldev-&gt;</span><span class="hljs-function"><span class="hljs-title">desc</span>-&gt;</span>confops;<br>int ret;<br>...<br>    <span class="hljs-function"><span class="hljs-title">ret</span> = ops-&gt;</span>pin_config_group_set(pctldev,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.group_or_pin,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.configs,<br>        <span class="hljs-function"><span class="hljs-title">setting</span>-&gt;</span><span class="hljs-keyword">data</span>.configs.num_configs);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>根据之前在.probe 分配注册的函数，就是在这里被执行的.</p><h2 id="二、DTB解析"><a href="#二、DTB解析" class="headerlink" title="二、DTB解析"></a>二、DTB解析</h2><h3 id="1-pincontroller"><a href="#1-pincontroller" class="headerlink" title="1.pincontroller"></a>1.pincontroller</h3><h4 id="3-1首先是描述、获得引脚"><a href="#3-1首先是描述、获得引脚" class="headerlink" title="3.1首先是描述、获得引脚"></a>3.1首先是描述、获得引脚</h4><p>打开内核源码目录  drivers\pinctrl\freescale\pinctrl-imx6ul.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> imx6ul_pinctrl_of_match[] = &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>, .data = &amp;imx6ul_pinctrl_info, &#125;,<br>&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ull-iomuxc-snvs&quot;</span>, .data = &amp;imx6ull_snvs_pinctrl_info, &#125;,<br>&#123; <span class="hljs-comment">/* sentinel */</span> &#125;<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_driver</span> imx6ul_pinctrl_driver = &#123;<br>.driver = &#123;<br>.name = <span class="hljs-string">&quot;imx6ul-pinctrl&quot;</span>,<br>.of_match_table = imx6ul_pinctrl_of_match,<br>.suppress_bind_attrs = <span class="hljs-literal">true</span>,<br>&#125;,<br>.probe = imx6ul_pinctrl_probe,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">imx6ul_pinctrl_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl_soc_info</span> *pinctrl_info;<br><br>pinctrl_info = <span class="hljs-built_in">of_device_get_match_data</span>(&amp;pdev-&gt;dev);<br><span class="hljs-keyword">if</span> (!pinctrl_info)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">imx_pinctrl_probe</span>(pdev, pinctrl_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 platform_driver 支持  “fsl,imx6ul-iomuxc”、”fsl,imx6ull-iomuxc-snvs”这两个平台设备，然后再probe函数调用 imx_pinctrl_probe</p><p>进入到 imx_pinctrl_probe(pdev, pinctrl_info)</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">int imx_pinctrl_probe(struct platform_device *pdev,<br>      const struct imx_pinctrl_soc_info *info)<br>&#123;<br>struct regmap_config config = &#123; .<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;gpr&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *dev_np = pdev-&gt;</span>dev.of_node;<br>struct pinctrl_desc *imx_pinctrl_desc;<br>struct device_node *np;<br>struct imx_pinctrl *ipctl;<br>struct regmap *gpr;<br>int ret, i;<br>...<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(*imx_pinctrl_desc),<br>GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!imx_pinctrl_desc)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span> = info-&gt;</span>pins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">npins</span> = info-&gt;</span>npins;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pctlops = &amp;imx_pctrl_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>pmxops = &amp;imx_pmx_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>confops = &amp;imx_pinconf_ops;<br><span class="hljs-function"><span class="hljs-title">imx_pinctrl_desc</span>-&gt;</span>owner = THIS_MODULE;<br>...<br><br>...<br>ret = imx_pinctrl_probe_dt(pdev, ipctl);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>看重点，这里就是在构造一个 pinctrl_desc 的结构体。</p><p>那么引脚是怎么获得的呢？</p><h4 id="3-2解析设备树"><a href="#3-2解析设备树" class="headerlink" title="3.2解析设备树"></a>3.2解析设备树</h4><p>进入 imx_pinctrl_probe_dt()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> int <span class="hljs-title function_ invoke__">imx_pinctrl_probe_dt</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_device</span> *pdev,<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl</span> *ipctl)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device_node</span> *np = pdev<span class="hljs-punctuation">-&gt;</span>dev.of_node;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device_node</span> *child;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *pctl = ipctl<span class="hljs-punctuation">-&gt;</span>pctl;<br><span class="hljs-type">u32</span> nfuncs = <span class="hljs-number">0</span>;<br><span class="hljs-type">u32</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flat_funcs;<br><br><span class="hljs-keyword">if</span> (!np)<br><span class="hljs-keyword">return</span> -ENODEV;<br><span class="hljs-comment">/* 判断设备树结构是不是 flat 模式 */</span><br>flat_funcs = <span class="hljs-title function_ invoke__">imx_pinctrl_dt_is_flat_functions</span>(np);<br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br>nfuncs = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* 获得有多少个function (多少个子节点) */</span><br>nfuncs = <span class="hljs-title function_ invoke__">of_get_child_count</span>(np);<br><span class="hljs-keyword">if</span> (nfuncs == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-title function_ invoke__">dev_err</span>(&amp;pdev<span class="hljs-punctuation">-&gt;</span>dev, <span class="hljs-string">&quot;no functions defined\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 对于每一个function(子节点) 都会去分配一个 function_desc 结构体*/</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nfuncs; i++) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">function_desc</span> *function;<br><br>function = <span class="hljs-title function_ invoke__">devm_kzalloc</span>(&amp;pdev<span class="hljs-punctuation">-&gt;</span>dev, <span class="hljs-title function_ invoke__">sizeof</span>(*function),<br>GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!function)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-title function_ invoke__">mutex_lock</span>(&amp;ipctl<span class="hljs-punctuation">-&gt;</span>mutex);<br><span class="hljs-title function_ invoke__">radix_tree_insert</span>(&amp;pctl<span class="hljs-punctuation">-&gt;</span>pin_function_tree, i, function);<br><span class="hljs-title function_ invoke__">mutex_unlock</span>(&amp;ipctl<span class="hljs-punctuation">-&gt;</span>mutex);<br>&#125;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_functions = nfuncs;<br><br>ipctl<span class="hljs-punctuation">-&gt;</span>group_index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups = <span class="hljs-title function_ invoke__">of_get_child_count</span>(np);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups = <span class="hljs-number">0</span>;<br>for_each_child_of_node(np, child)<br><span class="hljs-comment">/* 计算子function下又有多少个group(子节点)*/</span><br>pctl<span class="hljs-punctuation">-&gt;</span>num_groups += <span class="hljs-title function_ invoke__">of_get_child_count</span>(child);<br>&#125;<br><br><span class="hljs-keyword">if</span> (flat_funcs) &#123;<br><span class="hljs-title function_ invoke__">imx_pinctrl_parse_functions</span>(np, ipctl, <span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i = <span class="hljs-number">0</span>;<br>for_each_child_of_node(np, child)<br><span class="hljs-title function_ invoke__">imx_pinctrl_parse_functions</span>(child, ipctl, i++);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用 <code>imx_pinctrl_parse_functions()</code>，从设备树中提取每个 function 下的 group 和 pins，解析结构体并缓存。</p><p>补充：这里多次判断了 flat_funcs 这个值，设备树有两种组织形式：</p><p>（1）Flat 模式：所有 group 都直接定义在顶层 iomuxc 节点下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">pinctrl<span class="hljs-meta">@20e0000</span> &#123;<br>    pinctrl_uart1: uart1grp &#123;<br>        fsl,pins = <span class="hljs-variable">&lt;...&gt;</span>;<br>    &#125;;<br>    pinctrl_i2c1: i2c1grp &#123;<br>        fsl,pins = <span class="hljs-variable">&lt;...&gt;</span>;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）Function 分组模式（非 flat）：顶层为 function，function 下再分 group</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">pinctrl<span class="hljs-operator">@</span><span class="hljs-number">20e0000</span> &#123;<br>    <span class="hljs-keyword">uart1</span> &#123;<br>        <span class="hljs-keyword">uart1grp</span> &#123;<br>            fsl,pins <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;...&gt;</span>;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-keyword">i2c1</span> &#123;<br>        <span class="hljs-keyword">i2c1grp</span> &#123;<br>            fsl,pins <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;...&gt;</span>;<br>        &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接着来看具体怎么解析的，首先是 function</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int imx_pinctrl_parse_functions(struct device_node *np,<br>                           struct imx_pinctrl *ipctl,<br>       u32 index)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> pinctrl_dev *pctl = ipctl-&gt;</span>pctl;<br>struct function_desc *func;<br>struct group_desc *grp;<br>const char **group_names;<br>u32 i;<br><br><span class="hljs-function"><span class="hljs-title">dev_dbg</span>(pctl-&gt;</span>dev, <span class="hljs-string">&quot;parse function(%d): %pOFn\n&quot;</span>, index, np);<br><br>func = pinmux_generic_get_function(pctl, index);<br><span class="hljs-keyword">if</span> (!func)<br>return -EINVAL;<br><br><span class="hljs-comment">/* Initialise function */</span><br><span class="hljs-comment">/* 设置为设备树 function 节点名 */</span><br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">func</span>.<span class="hljs-keyword">name</span> = np-&gt;</span><span class="hljs-keyword">name</span>;<br><span class="hljs-comment">/*  该 function 下有几个 group */</span><br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span>func.ngroups = of_get_child_count(np);<br><span class="hljs-function"><span class="hljs-title">if</span> (func-&gt;</span>func.ngroups == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-function"><span class="hljs-title">dev_info</span>(ipctl-&gt;</span>dev, <span class="hljs-string">&quot;no groups defined in %pOF\n&quot;</span>, np);<br>return -EINVAL;<br>&#125;<br><span class="hljs-comment">/* 分配 group 名称数组，稍后填入所有 group 的名字 */</span><br><span class="hljs-function"><span class="hljs-title">group_names</span> = devm_kcalloc(ipctl-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, func-&gt;</span>func.ngroups,<br>   <span class="hljs-function"><span class="hljs-title">sizeof</span>(*func-&gt;</span>func.groups), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!group_names)<br>return -ENOMEM;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 将每个子 group 的名字填入 groups 数组，用于 framework 调用 pinmux_enable_setting() 时识别 group */</span><br>for_each_child_of_node_scoped(np, child)<br><span class="hljs-function"><span class="hljs-title">group_names</span>[i++] = child-&gt;</span><span class="hljs-keyword">name</span>;<br><span class="hljs-function"><span class="hljs-title">func</span>-&gt;</span>func.groups = group_names;<br><br>i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*  遍历每个 group，注册到 pinctrl */</span><br>for_each_child_of_node_scoped(np, child) &#123;<br><span class="hljs-function"><span class="hljs-title">grp</span> = devm_kzalloc(ipctl-&gt;</span>dev, sizeof(*grp), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!grp)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">mutex_lock</span>(&amp;ipctl-&gt;</span>mutex);<br><span class="hljs-function"><span class="hljs-title">radix_tree_insert</span>(&amp;pctl-&gt;</span>pin_group_tree,<br>  <span class="hljs-function"><span class="hljs-title">ipctl</span>-&gt;</span>group_index++, grp);<br><span class="hljs-function"><span class="hljs-title">mutex_unlock</span>(&amp;ipctl-&gt;</span>mutex);<br><span class="hljs-comment">/* 进一步解析 fsl,pins 属性 */</span><br>imx_pinctrl_parse_groups(child, grp, ipctl, i++);<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个 function 都会解析成一个 function_desc 结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">function_desc</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinfunction</span> func;<br><span class="hljs-type">void</span> *data;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinfunction</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> *groups;<br><span class="hljs-type">size_t</span> ngroups;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再通过 imx_pinctrl_parse_groups() 将每个group 解析为一个 group_desc 结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">group_desc</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pingroup</span> grp;<br><span class="hljs-type">void</span> *data;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pingroup</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pins;<br><span class="hljs-type">size_t</span> npins;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进入imx_pinctrl_parse_groups()</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">imx_pinctrl_parse_groups</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> group_desc *grp,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> imx_pinctrl *ipctl,</span></span><br><span class="hljs-params"><span class="hljs-function">    u32 index)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pinctrl_soc_info</span> *info = ipctl-&gt;info;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">imx_pin</span> *pin;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pins;<br><span class="hljs-type">int</span> size, pin_size;<br><span class="hljs-type">const</span> __be32 *list;<br><span class="hljs-type">int</span> i;<br>...<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; grp-&gt;grp.npins; i++) &#123;<br>    pin = &amp;((<span class="hljs-keyword">struct</span> imx_pin *)(grp-&gt;data))[i];<br>    <span class="hljs-keyword">if</span> (info-&gt;flags &amp; IMX_USE_SCU)<br>        info-&gt;<span class="hljs-built_in">imx_pinctrl_parse_pin</span>(ipctl, &amp;pins[i], pin, &amp;list);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">/* 解析单个引脚 */</span><br>        <span class="hljs-built_in">imx_pinctrl_parse_pin_mmio</span>(ipctl, &amp;pins[i], pin, &amp;list, np);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里又出现一个 struct imx_pin ,因为不管这一组group里有多少个pin，最终都是一个一个来解析的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin</span> &#123;<br>unsigned int pin;<br><span class="hljs-built_in">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin_mmio</span> mmio;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">imx_pin_scu</span> scu;<br>&#125; conf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进入 imx_pinctrl_parse_pin_mmio()</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void imx_pinctrl_parse_pin_mmio(struct imx_pinctrl *ipctl,<br>       unsigned int *pin_id, struct imx_pin *pin,<br>       const __be32 **list_p,<br>       struct device_node *np)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">const</span> struct imx_pinctrl_soc_info *info = ipctl-&gt;</span>info;<br><span class="hljs-function"><span class="hljs-title">struct</span> imx_pin_mmio *pin_mmio = &amp;pin-&gt;</span>conf.mmio;<br>struct imx_pin_reg *pin_reg;<br>const __be32 *list = *list_p;<br>u32 mux_reg, conf_reg;<br>u32 config;<br><br>mux_reg = be32_to_cpu(*list++);<br><br><span class="hljs-function"><span class="hljs-title">if</span> (!(info-&gt;</span>flags &amp; ZERO_OFFSET_VALID) &amp;&amp; !mux_reg)<br>mux_reg = -<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-title">if</span> (info-&gt;</span>flags &amp; SHARE_MUX_CONF_REG) &#123;<br>conf_reg = mux_reg;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>conf_reg = be32_to_cpu(*list++);<br><span class="hljs-keyword">if</span> (!conf_reg)<br>conf_reg = -<span class="hljs-number">1</span>;<br>&#125;<br><br>*pin_id = (mux_reg != -<span class="hljs-number">1</span>) ? mux_reg / <span class="hljs-number">4</span> : conf_reg / <span class="hljs-number">4</span>;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span> = &amp;ipctl-&gt;</span>pin_regs[*pin_id];<br><span class="hljs-function"><span class="hljs-title">pin</span>-&gt;</span>pin = *pin_id;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span>-&gt;</span>mux_reg = mux_reg;<br><span class="hljs-function"><span class="hljs-title">pin_reg</span>-&gt;</span>conf_reg = conf_reg;<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>input_reg = be32_to_cpu(*list++);<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>mux_mode = be32_to_cpu(*list++);<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>input_val = be32_to_cpu(*list++);<br><br>config = be32_to_cpu(*list++);<br><br><span class="hljs-comment">/* SION bit is in mux register */</span><br><span class="hljs-keyword">if</span> (config &amp; IMX_PAD_SION)<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>mux_mode |= IOMUXC_CONFIG_SION;<br><span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span>config = config &amp; ~IMX_PAD_SION;<br><br>*list_p = list;<br><br><span class="hljs-function"><span class="hljs-title">dev_dbg</span>(ipctl-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, &quot;%s: 0x%x 0x%08lx&quot;, info-&gt;</span>pins[*pin_id].<span class="hljs-keyword">name</span>,<br>     <span class="hljs-function"><span class="hljs-title">pin_mmio</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">mux_mode</span>, pin_mmio-&gt;</span>config);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以清楚的看到，就是根据设备树的信息来记录寄存器的值，这些信息到保存到了 struct imx_pin_mmio 里。</p><h2 id="三、pinctrl-cliend使用过程"><a href="#三、pinctrl-cliend使用过程" class="headerlink" title="三、pinctrl cliend使用过程"></a>三、pinctrl cliend使用过程</h2><p>只要它是一个设备，那么就会和一个相对应的驱动去匹配，在匹配之前会调用一个 really_probe().</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">really_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-comment">/* If using pinctrl, bind pins now before probing */</span><br>ret = <span class="hljs-built_in">pinctrl_bind_pins</span>(dev);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">int pinctrl_bind_pins(struct device *dev)<br>&#123;<br><span class="hljs-comment">/* 上面提到的map to setting */</span><br><span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p = devm_pinctrl_get(dev);              &lt;------------------------------<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p)) &#123;<br>dev_dbg(dev, <span class="hljs-string">&quot;no pinctrl handle\n&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">ret</span> = PTR_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p);<br>goto cleanup_alloc;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">init_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p, <br>PINCTRL_STATE_INIT);<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state)) &#123;<br><span class="hljs-comment">/* Not supplying this state is perfectly legal */</span><br>dev_dbg(dev, <span class="hljs-string">&quot;no init pinctrl state\n&quot;</span>);<br><br><span class="hljs-comment">/* 需要在转换之后去使用 */</span><br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>p,&lt;------------------------------<br>   <span class="hljs-function"><span class="hljs-title">dev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>default_state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">p</span>, dev-&gt;</span><span class="hljs-function"><span class="hljs-title">pins</span>-&gt;</span>init_state);<br>&#125;<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 pinctrl_select_state()</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">pinctrl_select_state</span>()</span><br><span class="hljs-function"><span class="hljs-title">pinctrl_commit_state</span>()</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)<br>&#123;<br>...<br><span class="hljs-comment">/* Apply all the settings for the new state - pinmux first */</span><br>list_for_each_entry(<span class="hljs-keyword">setting</span>, &amp;state-&gt;settings, node) &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">setting</span>-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = pinmux_enable_setting(<span class="hljs-keyword">setting</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-literal">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/* Apply all the settings for the new state - pinconf after */</span><br>list_for_each_entry(<span class="hljs-keyword">setting</span>, &amp;state-&gt;settings, node) &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">setting</span>-&gt;type) &#123;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br><span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>ret = pinconf_apply_setting(<span class="hljs-keyword">setting</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-literal">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个宏定义在哪里被设置的呢？</p><p>就是在最开始的 dt_node_to_map()里</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">static</span> int imx_dt_node_to_map(struct pinctrl_dev *pctldev,<br>struct device_node *np,<br>struct pinctrl_map **map, unsigned *num_maps)<br>&#123;<br>...<br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">type</span> = <span class="hljs-type">PIN_MAP_TYPE_MUX_GROUP</span>;</span><br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">data</span>.mux.function = parent-&gt;name;</span><br>new_map[<span class="hljs-number">0</span>].<span class="hljs-class"><span class="hljs-keyword">data</span>.mux.group = np-&gt;name;</span><br>of_node_put(parent);<br><br>    new_map[j].<span class="hljs-class"><span class="hljs-keyword">type</span> = <span class="hljs-type">PIN_MAP_TYPE_CONFIGS_PIN</span>;</span><br>    new_map[j].<span class="hljs-class"><span class="hljs-keyword">data</span>.configs.group_or_pin =</span><br>    pin_get_name(pctldev, pin-&gt;pin);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于MainLine Kernel的GPIO子系统分析</title>
    <link href="/2025/05/03/GPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/05/03/GPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、层次与数据结构"><a href="#一、层次与数据结构" class="headerlink" title="一、层次与数据结构"></a>一、层次与数据结构</h2><p>GPIO子系统主要的几个数据结构：</p><p>struct gpio_chip {}；</p><p>struct gpio_device {}；</p><p>struct gpio_desc {}；</p><p>对于一个GPIO Cnotroller ,都有相对应的一个 gpio_chip结构体，通过其内部的函数指针最终来操作硬件。</p><p>struct gpio_chip定义如下 include\linux\gpio\driver.h</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*label;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span>*gpiodev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>*parent;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwnode_handle</span>*fwnode;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span>*owner;<br><br><span class="hljs-built_in">int</span>(*request)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">void</span>(*free)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*get_direction)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*direction_input)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*direction_output)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">int</span>(*get)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br><span class="hljs-built_in">int</span>(*get_multiple)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">void</span>(*set)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">void</span>(*set_multiple)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">int</span>(*set_rv)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset,<br>  <span class="hljs-type">int</span> value);<br><span class="hljs-built_in">int</span>(*set_multiple_rv)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mask,<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *bits);<br><span class="hljs-built_in">int</span>(*set_config)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> config);<br><span class="hljs-built_in">int</span>(*to_irq)(<span class="hljs-keyword">struct</span> gpio_chip *gc,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset);<br>..........<br><br><span class="hljs-type">int</span>base;<br>u16ngpio;<br>u16offset;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*<span class="hljs-type">const</span> *names;<br><span class="hljs-type">bool</span>can_sleep;<br></code></pre></td></tr></table></figure><p>在驱动里定义并初始化一个gpio_chip，使用 gpiochip_add_data()注册。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xl">#define gpiochip_add_data(gc, <span class="hljs-keyword">data</span>) (&#123;\<br>static struct lock_class_key lock_key;\<br>static struct lock_class_key request_key;  \<br>gpiochip_add_data_with_key(gc, <span class="hljs-keyword">data</span>, &amp;lock_key, \       &lt;-----实际调用函数<br>   &amp;request_key);  \<br>&#125;)<br><br>************<br>************<br>gpiochip_add_data_with_key(gc, <span class="hljs-keyword">data</span>, &amp;lock_key, <br>               &amp;request_key)<br> &#123;<br> ........<br> <br> <span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>dev.type = &amp;gpio_dev_type;<br><span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>dev.bus = &amp;gpio_bus_type;<br><br><span class="hljs-comment">/* gdev 绑定 gpio_device */</span><br><span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>.parent = gc-&gt;</span>parent;<br><span class="hljs-function"><span class="hljs-title">rcu_assign_pointer</span>(gdev-&gt;</span>chip, gc);<br><span class="hljs-comment">/* 反向绑定 */</span><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>gpiodev = gdev;<br>gpiochip_set_data(gc, <span class="hljs-keyword">data</span>);<br> <br> ........<br> <br>    <span class="hljs-function"><span class="hljs-title">base</span> = gc-&gt;</span>base;<br>            <span class="hljs-keyword">if</span> (base &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">/* 自动分配 */</span><br>                <span class="hljs-function"><span class="hljs-title">base</span> = gpiochip_find_base_unlocked(gc-&gt;</span>ngpio);<br>                <span class="hljs-keyword">if</span> (base &lt; <span class="hljs-number">0</span>) &#123;<br>                    ret = base;<br>                    base = <span class="hljs-number">0</span>;<br>                    goto err_free_label;<br>                &#125;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * <span class="hljs-doctag">TODO:</span> it should not be necessary to reflect the</span><br><span class="hljs-comment">                 * assigned base outside of the GPIO subsystem. Go over</span><br><span class="hljs-comment">                 * drivers and see if anyone makes use of this, else</span><br><span class="hljs-comment">                 * drop this and assign a poison instead.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>base = base;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">dev_warn</span>(&amp;gdev-&gt;</span>dev,<br>                     <span class="hljs-string">&quot;Static allocation of GPIO base is deprecated, use dynamic allocation.\n&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-title">gdev</span>-&gt;</span>base = base;<br><span class="hljs-comment">/* 添加到链表 */</span><br>            ret = gpiodev_add_to_list_unlocked(gdev);<br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                chip_err(gc, <span class="hljs-string">&quot;GPIO integer space overlap, cannot add chip\n&quot;</span>);<br>                goto err_free_label;<br>            &#125;<br>            ......<br>&#125;<br></code></pre></td></tr></table></figure><p>其中比较关键的是</p><p>​       gdev-&gt;dev.parent &#x3D; gc-&gt;parent;<br>​rcu_assign_pointer(gdev-&gt;chip, gc);<br>​&#x2F;* 反向绑定 *&#x2F;<br>​gc-&gt;gpiodev &#x3D; gdev;</p><p>实现了gpio_chip &lt;——-&gt; gpio_device 的双向绑定。</p><p>我们可以看到，这个函数在初始化完这个结构体后，<code>piodev_add_to_list_unlocked</code>  并把它加入全局链表 gpio_devices，正式注册到系统中供其他子系统（比如 pinctrl、IRQ、设备树解析等）使用。</p><h3 id="问：那么全局链表-gpio-devices-是干嘛的？"><a href="#问：那么全局链表-gpio-devices-是干嘛的？" class="headerlink" title="问：那么全局链表 gpio_devices 是干嘛的？"></a>问：那么全局链表 <code>gpio_devices</code> 是干嘛的？</h3><p>这是所有注册到内核的 GPIO 控制器的“数据库”，很多操作都会遍历它，比如：</p><p>1.用户态访问 <code>/sys/class/gpio/</code></p><p>2.设备树中 <code>gpio = &lt;&amp;gpioX ...&gt;</code> 时查找控制器</p><p>3.子系统（如 <code>pinctrl</code>, <code>irqchip</code>）查找 GPIO 资源</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">gpio_devices 里存的是所有注册的 gpio_device（每个 controller 一份）；<br><br>每个 gpio_device 管理一个 <span class="hljs-keyword">desc</span> 数组；<br><br>查找 GPIO 时，从dtb → 找 gpio controller → 找 <span class="hljs-keyword">desc</span>[<span class="hljs-keyword">offset</span>]<br></code></pre></td></tr></table></figure><h2 id="二、函数分析"><a href="#二、函数分析" class="headerlink" title="二、函数分析"></a>二、函数分析</h2><p>我们在分配GPIO资源的时候一般有两种方法，第一种是传统方法，自己在驱动手动实现一个gpio_request()gpio_direction_input()等，另一种则是使用dtb来指定好引脚信息，通过platfrom_device解析后，系统自动gpio_request() gpio_direction_input()…….。</p><h3 id="1-首先是gpiod-get"><a href="#1-首先是gpiod-get" class="headerlink" title="1.首先是gpiod_get()"></a>1.首先是gpiod_get()</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * gpiod_get - obtain a GPIO for a given GPIO function</span><br><span class="hljs-comment"> * @dev:GPIO consumer, can be NULL for system-global GPIOs</span><br><span class="hljs-comment"> * @con_id:function within the GPIO consumer</span><br><span class="hljs-comment"> * @flags:optional GPIO initialization flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns:</span><br><span class="hljs-comment"> * The GPIO descriptor corresponding to the function @con_id of device</span><br><span class="hljs-comment"> * dev, -ENOENT if no GPIO has been assigned to the requested function, or</span><br><span class="hljs-comment"> * another IS_ERR() code if an error occurred while trying to acquire the GPIO.</span><br><span class="hljs-comment"> */</span><br>struct gpio_desc *__must_check <span class="hljs-built_in">gpiod_get</span>(struct device *dev, const char *con_id,<br> enum gpiod_flags flags)<br>&#123;<br>return <span class="hljs-built_in">gpiod_get_index</span>(dev, con_id, <span class="hljs-number">0</span>, flags);<br>&#125;<br><span class="hljs-built_in">EXPORT_SYMBOL_GPL</span>(gpiod_get);<br></code></pre></td></tr></table></figure><h3 id="2-gpiod-get-—-gpiod-get-index"><a href="#2-gpiod-get-—-gpiod-get-index" class="headerlink" title="2.gpiod_get( )   —-&gt;  gpiod_get_index()"></a>2.gpiod_get( )   —-&gt;  gpiod_get_index()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * gpiod_get_index - obtain a GPIO from a multi-index GPIO function</span><br><span class="hljs-comment"> * @dev:GPIO consumer, can be NULL for system-global GPIOs</span><br><span class="hljs-comment"> * @con_id:function within the GPIO consumer</span><br><span class="hljs-comment"> * @idx:index of the GPIO to obtain in the consumer</span><br><span class="hljs-comment"> * @flags:optional GPIO initialization flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This variant of gpiod_get() allows to access GPIOs other than the first</span><br><span class="hljs-comment"> * defined one for functions that define several GPIOs.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns:</span><br><span class="hljs-comment"> * A valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the</span><br><span class="hljs-comment"> * requested function and/or index, or another IS_ERR() code if an error</span><br><span class="hljs-comment"> * occurred while trying to acquire the GPIO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span> *<span class="hljs-function">__must_check <span class="hljs-title">gpiod_get_index</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">enum</span> gpiod_flags flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwnode_handle</span> *fwnode = dev ? <span class="hljs-built_in">dev_fwnode</span>(dev) : <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *devname = dev ? <span class="hljs-built_in">dev_name</span>(dev) : <span class="hljs-string">&quot;?&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *label = con_id ?: devname;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gpiod_find_and_request</span>(dev, fwnode, con_id, idx, flags, label, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-built_in">EXPORT_SYMBOL_GPL</span>(gpiod_get_index);<br></code></pre></td></tr></table></figure><h3 id="3-—–-gpiod-find-and-request-："><a href="#3-—–-gpiod-find-and-request-：" class="headerlink" title="3,   —–&gt;gpiod_find_and_request()："></a>3,   —–&gt;gpiod_find_and_request()：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs stata">struct gpio_desc *gpiod_find_and_request(struct device *consumer,<br> struct fwnode_handle *fwnode,<br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *con_id,<br> unsigned int idx,<br> enum gpiod_flags flags,<br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">label</span>,<br> bool platform_lookup_allowed)<br>&#123;<br>unsigned long lookupflags = GPIO_LOOKUP_FLAGS_DEFAULT;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = function_name_or_default(con_id);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * scoped_guard() is implemented as a for loop, meaning static</span><br><span class="hljs-comment"> * analyzers will complain about these two not being initialized.</span><br><span class="hljs-comment"> */</span><br>struct gpio_desc *<span class="hljs-keyword">desc</span> = NULL;<br>int <span class="hljs-keyword">ret</span> = 0;<br><br>scoped_guard(srcu, &amp;gpio_devices_srcu) &#123;<br><span class="hljs-comment">/*gpiod_find_by_fwnode 从设备树 (DT) 或 ACPI 中查找该 GPIO 的 gpio_desc。</span><br><span class="hljs-comment"> 利用 con_id 和 idx 来定位某个 label 名下的某个 GPIO。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">desc</span> = gpiod_find_by_fwnode(fwnode, consumer, con_id, idx,<br>    &amp;flags, &amp;lookupflags);<br><span class="hljs-keyword">if</span> (gpiod_not_found(<span class="hljs-keyword">desc</span>) &amp;&amp; platform_lookup_allowed) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Either we are not using DT or ACPI, or their lookup</span><br><span class="hljs-comment"> * did not return a result. In that case, use platform</span><br><span class="hljs-comment"> * lookup as a fallback.</span><br><span class="hljs-comment"> */</span><br>dev_dbg(consumer,<br><span class="hljs-string">&quot;using lookup tables for GPIO lookup\n&quot;</span>);<br><span class="hljs-keyword">desc</span> = gpiod_find(consumer, con_id, idx, &amp;lookupflags);<br>&#125;<br><br><span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-keyword">desc</span>)) &#123;<br>dev_dbg(consumer, <span class="hljs-string">&quot;No GPIO consumer %s found\n&quot;</span>, name);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If a connection label was passed use that, else attempt to use</span><br><span class="hljs-comment"> * the device name as label</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/* 这里就是通过DTB规定好的GPIO引脚，自动申请 */</span><br><span class="hljs-keyword">ret</span> = gpiod_request(<span class="hljs-keyword">desc</span>, <span class="hljs-keyword">label</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>) &#123;<br><span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">ret</span> == -EBUSY &amp;&amp; flags &amp; GPIOD_FLAGS_BIT_NONEXCLUSIVE))<br><span class="hljs-keyword">return</span> ERR_PTR(<span class="hljs-keyword">ret</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This happens when there are several consumers for</span><br><span class="hljs-comment"> * the same GPIO line: we just return here without</span><br><span class="hljs-comment"> * further initialization. It is a bit of a hack.</span><br><span class="hljs-comment"> * This is necessary to support fixed regulators.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">FIXME:</span> Make this more sane and safe.</span><br><span class="hljs-comment"> */</span><br>dev_info(consumer, <span class="hljs-string">&quot;nonexclusive access to GPIO for %s\n&quot;</span>, name);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br><br><span class="hljs-keyword">ret</span> = gpiod_configure_flags(<span class="hljs-keyword">desc</span>, con_id, lookupflags, flags);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> &lt; 0) &#123;<br>gpiod_put(<span class="hljs-keyword">desc</span>);<br>dev_err(consumer, <span class="hljs-string">&quot;setup of GPIO %s failed: %d\n&quot;</span>, name, <span class="hljs-keyword">ret</span>);<br><span class="hljs-keyword">return</span> ERR_PTR(<span class="hljs-keyword">ret</span>);<br>&#125;<br><br>gpiod_line_state_notify(<span class="hljs-keyword">desc</span>, GPIO_V2_LINE_CHANGED_REQUESTED);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">desc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这和函数内部实现了解析设备树 gpiod_find_by_fwnode ，引脚申请、标志位设置。</p><h2 id="三、i-mx6ull-probe解析"><a href="#三、i-mx6ull-probe解析" class="headerlink" title="三、i.mx6ull probe解析"></a>三、i.mx6ull probe解析</h2><h3 id="1-打开驱动源码-drivers-gpio-gpio-mxc-c，找到probe函数"><a href="#1-打开驱动源码-drivers-gpio-gpio-mxc-c，找到probe函数" class="headerlink" title="1.打开驱动源码  drivers\gpio\gpio-mxc.c，找到probe函数"></a>1.打开驱动源码  drivers\gpio\gpio-mxc.c，找到probe函数</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int mxc_gpio_probe(struct platform_device *pdev)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">struct</span> device_node *np = pdev-&gt;</span>dev.of_node;<br>struct mxc_gpio_port *port;   <br>int irq_count;<br>int irq_base;<br>int err;<br><br><span class="hljs-function"><span class="hljs-title">port</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(*port), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!port)<br>return -ENOMEM;<br><br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span> = &amp;pdev-&gt;</span>dev;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hwdata</span> = device_get_match_data(&amp;pdev-&gt;</span>dev);<br><br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-title">if</span> (IS_ERR(port-&gt;</span>base))<br><span class="hljs-function"><span class="hljs-title">return</span> PTR_ERR(port-&gt;</span>base);<br>......<br>mxc_update_irq_chained_handler(port, <span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-title">err</span> = bgpio_init(&amp;port-&gt;</span><span class="hljs-function"><span class="hljs-title">gc</span>, &amp;pdev-&gt;</span>dev, <span class="hljs-number">4</span>,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_PSR,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_DR, NULL,<br> <span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>base + GPIO_GDIR, NULL,<br> BGPIOF_READ_OUTPUT_REG_SET);<br><span class="hljs-keyword">if</span> (err)<br>goto out_bgio;<br>.......<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.request = mxc_gpio_request;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.free = mxc_gpio_free;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.to_irq = mxc_gpio_to_irq;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.base = of_alias_get_id(np, <span class="hljs-string">&quot;gpio&quot;</span>) * <span class="hljs-number">32</span>;<br><br><span class="hljs-function"><span class="hljs-title">err</span> = devm_gpiochip_add_data(&amp;pdev-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, &amp;port-&gt;</span>gc, port);<br><span class="hljs-keyword">if</span> (err)<br>goto out_bgio;<br><br><span class="hljs-function"><span class="hljs-title">irq_base</span> = devm_irq_alloc_descs(&amp;pdev-&gt;</span>dev, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, numa_node_id());<br><span class="hljs-keyword">if</span> (irq_base &lt; <span class="hljs-number">0</span>) &#123;<br>err = irq_base;<br>goto out_bgio;<br>&#125;<br>......<br><span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;port-&gt;</span>node, &amp;mxc_gpio_ports);<br>return err;<br>&#125;<br><br>**************************<br>struct mxc_gpio_port &#123;<br>struct list_head node;<br>void __iomem *base;<br>struct clk *clk;<br>int irq;<br>int irq_high;<br>void (*mx_irq_handler)(struct irq_desc *desc);<br>struct irq_domain *domain;<br>struct gpio_chip gc;<br>.....<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到这个函数主要就是在对一个gpio_chip进行分配、设置、注册。gpio_chip 在struct mxc_gpio_port *port;   结构体中。</p><h3 id="2-bgpio-init"><a href="#2-bgpio-init" class="headerlink" title="2.bgpio_init()"></a>2.bgpio_init()</h3><p>重点关注probe里的 bgpio_init 函数，我们首先看传的参数： port-&gt;base + GPIO_PSR, port-&gt;base + GPIO_DR, NULL, port-&gt;base + GPIO_GDIR, NULL,这几个参数就是一些寄存器的虚拟地址，分别是状态寄存器，数据寄存器，方向寄存器.</p><p>我们再进入函数内部：核心函数bgpio_setup_io</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int bgpio_init(struct gpio_chip *<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> struct device *dev<span class="hljs-punctuation">,</span><br>       unsigned long sz<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dat<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *set<span class="hljs-punctuation">,</span><br>       <span class="hljs-type">void</span> __iomem *clr<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dirout<span class="hljs-punctuation">,</span> <span class="hljs-type">void</span> __iomem *dirin<span class="hljs-punctuation">,</span><br>       unsigned long flags)<br>&#123;<br>int <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>raw_spin_lock_init(&amp;<span class="hljs-keyword">gc</span>-&gt;bgpio_lock)<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;parent <span class="hljs-operator">=</span> dev<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;<span class="hljs-type">label</span> <span class="hljs-operator">=</span> dev_name(dev)<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;base <span class="hljs-operator">=</span> <span class="hljs-number">-1</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;request <span class="hljs-operator">=</span> bgpio_request<span class="hljs-comment">;</span><br><span class="hljs-keyword">gc</span>-&gt;be_bits <span class="hljs-operator">=</span> !!(flags &amp; BGPIOF_BIG_ENDIAN)<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">ret</span> <span class="hljs-operator">=</span> gpiochip_get_ngpios(<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> dev)<span class="hljs-comment">;</span><br>if (<span class="hljs-keyword">ret</span>)<br><span class="hljs-keyword">gc</span>-&gt;ngpio <span class="hljs-operator">=</span> <span class="hljs-keyword">gc</span>-&gt;bgpio_bits<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">ret</span> <span class="hljs-operator">=</span> bgpio_setup_io(<span class="hljs-keyword">gc</span><span class="hljs-punctuation">,</span> dat<span class="hljs-punctuation">,</span> set<span class="hljs-punctuation">,</span> clr<span class="hljs-punctuation">,</span> flags)<span class="hljs-comment">;</span><br>if (<span class="hljs-keyword">ret</span>)<br>return <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>return <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-bgpio-setup-io"><a href="#3-bgpio-setup-io" class="headerlink" title="3.bgpio_setup_io()"></a>3.bgpio_setup_io()</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int bgpio_setup_io(struct gpio_chip *gc,<br>  void __iomem *dat,<br>  void __iomem *set,<br>  void __iomem *clr,<br>  unsigned long flags)<br>&#123;<br><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_dat = dat;<br><span class="hljs-function"><span class="hljs-title">if</span> (!gc-&gt;</span>reg_dat)<br>return -EINVAL;<br><br><span class="hljs-keyword">if</span> (set &amp;&amp; clr) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_set = set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_clr = clr;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_with_clear;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple_with_clear;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (set &amp;&amp; !clr) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>reg_set = set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple_set;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; BGPIOF_NO_OUTPUT) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set_none;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = NULL;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set = bgpio_set;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>set_multiple = bgpio_set_multiple;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!(flags &amp; BGPIOF_UNREADABLE_REG_SET) &amp;&amp;<br>    (flags &amp; BGPIOF_READ_OUTPUT_REG_SET)) &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get = bgpio_get_set;<br><span class="hljs-function"><span class="hljs-title">if</span> (!gc-&gt;</span>be_bits)<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_set_multiple;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We deliberately avoid assigning the -&gt;get_multiple() call</span><br><span class="hljs-comment"> * for big endian mirrored registers which are ALSO reflecting</span><br><span class="hljs-comment"> * their value in the set register when used as output. It is</span><br><span class="hljs-comment"> * simply too much complexity, let the GPIO core fall back to</span><br><span class="hljs-comment"> * reading each line individually in that fringe case.</span><br><span class="hljs-comment"> */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get = bgpio_get;<br><span class="hljs-function"><span class="hljs-title">if</span> (gc-&gt;</span>be_bits)<br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_multiple_be;<br><span class="hljs-keyword">else</span><br><span class="hljs-function"><span class="hljs-title">gc</span>-&gt;</span>get_multiple = bgpio_get_multiple;<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它给我们去绑定了一些设置函数，这些函数都不需要我们去实现。这就是我们在驱动层调用gpiod_set最终执行到的地方。</p><p>这个功能都是由bgpio_init（）提供的，这个函数是 <strong>Linux GPIO 子系统提供的一个通用框架函数</strong>，用于简化<strong>标准寄存器布局的 GPIO 控制器驱动编写</strong>。在bgpio_init（）之后赋值的部分是 <strong>针对特定平台额外补充的能力函数</strong>，比如request&#x2F;free&#x2F;to_irq….</p><p>接着我们再次回到probe函数，有一个注册函数 err &#x3D; devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;port-&gt;gc, port);</p><p>我们跳进去查看：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define devm_gpiochip_add_data(dev, gc, data) (&#123; \</span><br><span class="hljs-keyword">static</span> struct lock_class_key lock_key;<span class="hljs-string">\</span><br><span class="hljs-keyword">static</span> struct lock_class_key request_key;  <span class="hljs-string">\</span><br>devm_gpiochip_add_data_with_key(dev, gc, data, &amp;lock_key, <span class="hljs-string">\</span><br>   &amp;request_key);  <span class="hljs-string">\</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到这里调用的就是我们之前分析过的 gpio_chip注册的那一套流程 devm_gpiochip_add_data_with_key()；</p><p>到此关于GPIO子系统的内部实现就简单分析到此。</p><p>未完……….</p><h2 id="四、platfrom-device-、platfrom-driver-match-过程"><a href="#四、platfrom-device-、platfrom-driver-match-过程" class="headerlink" title="四、platfrom_device 、platfrom_driver match 过程"></a>四、platfrom_device 、platfrom_driver match 过程</h2><h3 id="1-platfrom-device-注册过程"><a href="#1-platfrom-device-注册过程" class="headerlink" title="1.platfrom_device 注册过程"></a>1.platfrom_device 注册过程</h3><p>platfrom_device 注册的方式有两种：第一种是手动注册，用 <code>platform_device_register()</code> 自己注册设备，另一种则是设备树生成，系统启动时，<code>of_platform_populate()</code> 扫描设备树，发现 <code>compatible</code> 字段的节点就注册成 <code>platform_device</code>。</p><p>首先分析手动注册：进入platform_device_register（）；</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">int platform_device_register(struct platform_device *pdev)<br>&#123;<br>    device_initialize(&amp;pdev-&gt;dev);###初始化设备结构体 pdev-&gt;dev，清除未初始化字段，确保设备结构体状态正确。<br>    setup_pdev_dma_masks(pdev);<br>    return platform_device_add(pdev);     ###将驱动注册到内核中<br>&#125;<br></code></pre></td></tr></table></figure><p>依次进入platform_device_add（）—&gt;device_add()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">platform_device_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *dev = &amp;pdev-&gt;dev;<br>u32 i;<br><span class="hljs-type">int</span> ret;<br>...<br>ret = <span class="hljs-built_in">device_add</span>(dev);         &lt;----------- 添加到设备总线 <br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> failed;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>device_add()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">device_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">subsys_private</span> *sp;<br>...<br><span class="hljs-comment">/* notify platform of device entry */</span><br><span class="hljs-built_in">device_platform_notify</span>(dev);<br><br>error = <span class="hljs-built_in">bus_add_device</span>(dev);  &lt;-----将device加入到对应的 <span class="hljs-function">bus</span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">goto</span> BusError</span>;<br>.........<br>&#125;<br></code></pre></td></tr></table></figure><p>设备一旦添加到总线上，系统就会自动调用总线的匹配机制，找到与之匹配的驱动，进而调用驱动的 <code>.probe()</code> 函数。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs subunit">int bus_add_device(struct device *dev)<br>&#123;<br>pr_debug(&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;, sp-&gt;bus-&gt;name, dev_name(dev));<br><br><span class="hljs-keyword">error </span>= device_add_groups(dev, sp-&gt;bus-&gt;dev_groups);<br>if (error)<br>goto out_put;<br><br><span class="hljs-keyword">error </span>= sysfs_create_link(&amp;sp-&gt;devices_kset-&gt;kobj, &amp;dev-&gt;kobj, dev_name(dev));<br>if (error)<br>goto out_groups;<br><br><span class="hljs-keyword">error </span>= sysfs_create_link(&amp;dev-&gt;kobj, &amp;sp-&gt;subsys.kobj, &quot;subsystem&quot;);<br>if (error)<br>goto out_subsys;<br><br>klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;sp-&gt;klist_devices);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">device_add</span>()</span><br> └── <span class="hljs-function"><span class="hljs-title">bus_add_device</span>()</span><br>      └── <span class="hljs-function"><span class="hljs-title">bus_probe_device</span>()</span><br>           └── <span class="hljs-function"><span class="hljs-title">device_initial_probe</span>()</span><br>                └── <span class="hljs-function"><span class="hljs-title">driver_match_device</span>()</span><br>                     └── <span class="hljs-function"><span class="hljs-title">probe</span>()</span><br></code></pre></td></tr></table></figure><h3 id="2-设备树转换platfrom-device"><a href="#2-设备树转换platfrom-device" class="headerlink" title="2.设备树转换platfrom_device"></a>2.设备树转换platfrom_device</h3><h3 id="3-platfrom-driver-注册过程"><a href="#3-platfrom-driver-注册过程" class="headerlink" title="3.platfrom_driver 注册过程"></a>3.platfrom_driver 注册过程</h3><p>详细讲述了platfrom_driver   .probe函数是如何调用的。</p><p>但是二者之间稍有不同。暂时没有深入研究….（二者间.probe调用方式和时间）</p><h2 id="五、GPIO-与Pinctrl-的关联"><a href="#五、GPIO-与Pinctrl-的关联" class="headerlink" title="五、GPIO 与Pinctrl 的关联"></a>五、GPIO 与Pinctrl 的关联</h2><p>在硬件上并没有Pinctrl这个模块，它是由软件虚拟出来的一个概念，很多时候Pinctrl的功能都是由GPIO控制器来完成的,所以说他们是密切相关的。</p><p>有时候在去操作一个gpio引脚时，明明没有把它通过pinctrl配置为gpio模式，但还是能去使用，这是因为在硬件上gpio引脚都是连接在gpio控制器上的，所以默认就是gpio模式。</p><h3 id="1-gpio与pinctrl的映射关系"><a href="#1-gpio与pinctrl的映射关系" class="headerlink" title="1.gpio与pinctrl的映射关系"></a>1.gpio与pinctrl的映射关系</h3><p>pinctrl_desc 和 gpio_device结构体:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_desc</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_pin_desc</span> *pins;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_ops</span> *pctlops;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinmux_ops</span> *pmxops;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinconf_ops</span> *confops;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_custom_params;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinconf_generic_params</span> *custom_params;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pin_config_item</span> *custom_conf_items;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">bool</span> link_consumers;<br>&#125;;<br>*******************************************************************<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>dev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span>chrdev;<br><span class="hljs-type">int</span>id;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span>*mockdev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span>*owner;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> __rcu*chip;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>*descs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*valid_mask;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">srcu_struct</span>desc_srcu;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>base;<br>u16ngpio;<br><span class="hljs-type">bool</span>can_sleep;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*label;<br><span class="hljs-type">void</span>*data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>        list;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">raw_notifier_head</span> line_state_notifier;<br><span class="hljs-type">rwlock_t</span>line_state_lock;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">workqueue_struct</span>*line_state_wq;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">blocking_notifier_head</span> device_notifier;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">srcu_struct</span>srcu;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>先说结果，struct gpio_device里有一个struct gpio_desc *desc结构体，我们知道gpio_desc 就是某一个pin的描述符，我们说的映射关系就是如何将  struct gpio_desc *desc ——&gt; pinctrl_pin_desc *pins,然后由 pinctrl_desc 里的struct pinmux_ops *pmxops提供的reset（）、gpio_set_direction（）函数去操作设置gpio pin。</p><p>需要研究的就是这个映射过程。</p><p>设备树方面,以gpio1为例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">gpio1: gpio<span class="hljs-meta">@209c000</span> &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x0209c000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;</span>,<br>     <span class="hljs-variable">&lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;</span>;<br>clocks = <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_GPIO1&gt;</span>;<br>gpio-controller;<br><span class="hljs-comment">#gpio-cells = &lt;2&gt;;</span><br>interrupt-controller;<br><span class="hljs-comment">#interrupt-cells = &lt;2&gt;;</span><br>gpio-ranges = <span class="hljs-variable">&lt;&amp;iomuxc  0 23 10&gt;</span>, <span class="hljs-variable">&lt;&amp;iomuxc 10 17 6&gt;</span>,<br>      <span class="hljs-variable">&lt;&amp;iomuxc 16 33 16&gt;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到有一个gpio-ranges &#x3D; &lt;&amp;iomuxc  0 23 10&gt;, &lt;&amp;iomuxc 10 17 6&gt;,<br>      &lt;&amp;iomuxc 16 33 16&gt;; 属性：</p><p>&lt;&amp;iomuxc  0 23 10&gt; ：gpio1的第0个引脚要映射到pinctrl里的第23个引脚上，有10个引脚，可以看出一共有32个引脚。</p><p>那么在代码里怎么去表示呢？有两个结构体：gpio_pin_range    pinctrl_gpio_range</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_pin_range</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> node;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> *pctldev;     &lt;-------<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_gpio_range</span> range;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_gpio_range</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> node;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> base;         &lt;-------<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pin_base;     &lt;-------<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;   <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> *pins;   &lt;--------<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> *gc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最终就是映射到 pctldev 里，怎么映射？使用 range 表示，base表示GPIO系统中的引脚编号（注意，是整个GPIO系统，而不是某一个GPIO控制器，如gpio1_0 在这里可能就是 100，gpio1_1 在这里可能就是 101）。</p><p>pin_base则是pinctrl里的引脚编号（0~xxx）,pins表示引脚个数。</p><p>从gpiod_get()入手：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">gpiod<span class="hljs-emphasis">_get</span><br><span class="hljs-emphasis">gpiod_get_index</span><br><span class="hljs-emphasis">gpiod_find_and_request</span><br><span class="hljs-emphasis">gpiod_request</span><br><span class="hljs-emphasis">gpiod_request_</span>commit<br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gpiod_request_commit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gpio_desc *desc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-built_in">CLASS</span>(gpio_chip_guard, guard)(desc);<br><span class="hljs-keyword">if</span> (guard.gc-&gt;request) &#123;<br>ret = guard.gc-&gt;<span class="hljs-built_in">request</span>(guard.gc, offset);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>ret = -EBADE;<br>...<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip_guard</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_device</span> *gdev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_chip</span> *gc;<br><span class="hljs-type">int</span> idx;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到就是我们如上所说最终调用的就是 gpio_chip 里的 request 函数。（其实这里和上面分析的gpiod_get（）差不多，只是分析的不是同一个功能）。</p><p>在上面分析 device driver match 的过程中，gpio-mxc.c 里的probe函数有这么一段：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.request = mxc_gpio_request;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.free = mxc_gpio_free;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.to_irq = mxc_gpio_to_irq;<br><span class="hljs-function"><span class="hljs-title">port</span>-&gt;</span>gc.base = of_alias_get_id(np, <span class="hljs-string">&quot;gpio&quot;</span>) * <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure><p>可有看到这里设置了一个 mxc_gpio_request函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">mxc_gpio_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gpio_chip *chip, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = <span class="hljs-built_in">gpiochip_generic_request</span>(chip, offset);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pm_runtime_resume_and_get</span>(chip-&gt;parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个通用的gpio_request函数</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean">int gpiochip_generic_request(struct gpio_chip *gc, unsigned int offset)<br>&#123;<br>#ifdef CONFIG_PINCTRL<br><span class="hljs-keyword">if</span> (list_empty(&amp;gc-&gt;gpiodev-&gt;pin_ranges))<br>return <span class="hljs-number">0</span>;<br>#endif<br><br>return pinctrl_gpio_request(gc, offset);    &lt;------<br>&#125;<br><br>#########################################################<br><br>int pinctrl_gpio_request(struct gpio_chip *gc, unsigned int offset)<br>&#123;<br>struct pinctrl_gpio_range *range;<br>struct pinctrl_dev *pctldev;<br>int ret, pin;<br><br>ret = pinctrl_get_device_gpio_range(gc, offset, &amp;pctldev, &amp;range);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-keyword">if</span> (pinctrl_ready_for_gpio_range(gc, offset))<br>ret = <span class="hljs-number">0</span>;<br>return ret;<br>&#125;<br><br>mutex_lock(&amp;pctldev-&gt;mutex);<br><br><span class="hljs-comment">/* Convert to the pin controllers number space */</span><br>pin = gpio_to_pin(range, gc, offset);<br><br>ret = pinmux_request_gpio(pctldev, range, pin, gc-&gt;base + offset);<br><br>mutex_unlock(&amp;pctldev-&gt;mutex);<br><br>return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>pinctrl_gpio_request()里果然有一个pinctrl_ready_for_gpio_range()函数得到range,再通过gpio_to_pin（）将这个引脚转换为pin controllers number，然后执行pinmux_request_gpio(pctldev, range, pin, gc-&gt;base + offset)（这里从参数可以看出，传入的就是gpio系统的全局编号）。</p><p>再接着往下看，进入 pinmux_request_gpio()</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs clean">int pinmux_request_gpio(struct pinctrl_dev *pctldev,<br>struct pinctrl_gpio_range *range,<br>unsigned int pin, unsigned int gpio)<br>&#123;<br>const char *owner;<br>int ret;<br><br><span class="hljs-comment">/* Conjure some name stating what chip and pin this is taken by */</span><br>owner = kasprintf(GFP_KERNEL, <span class="hljs-string">&quot;%s:%d&quot;</span>, range-&gt;name, gpio);<br><span class="hljs-keyword">if</span> (!owner)<br>return -ENOMEM;<br><br>ret = pin_request(pctldev, pin, owner, range);     &lt;--------<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>kfree(owner);<br><br>return ret;<br>&#125;<br><br><br>#############################################<br><br>static int pin_request(struct pinctrl_dev *pctldev,<br>       int pin, const char *owner,<br>       struct pinctrl_gpio_range *gpio_range)<br>&#123;<br>struct pin_desc *desc;<br>const struct pinmux_ops *ops = pctldev-&gt;desc-&gt;pmxops;<br>int status = -EINVAL;<br>...<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * If there is no kind of request function for the pin we just assume</span><br><span class="hljs-comment"> * we got it by default and proceed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gpio_range &amp;&amp; ops-&gt;gpio_request_enable)<br><span class="hljs-comment">/* This requests and enables a single GPIO pin */</span><br>status = ops-&gt;gpio_request_enable(pctldev, gpio_range, pin);<br>else <span class="hljs-keyword">if</span> (ops-&gt;request)<br>status = ops-&gt;request(pctldev, pin);<br>else<br>status = <span class="hljs-number">0</span>;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>pin_request()里看到，如果 struct pinctrl_gpio_range 里提供了gpio_request_enable、request 函数，就把他设置为gpio功能，如果没有怎什么都不做。</p><p>以上就是大致的映射过程。有不对的地方望指正。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
